{"version":3,"sources":["Matrix.coffee"],"names":[],"mappings":"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","file":"Matrix.js","sourceRoot":"/source/","sourcesContent":["# ### Functions to calculate various Matrix transformations\r\nclass Matrix\r\n\r\n  # ## Get a 3x3 matrix for 2D rotation around an anchor point\r\n  # @param `radian` rotation angle in radian\r\n  # @param `anchor` anchor point of rotation\r\n  # @return an array representing a 3x3 matrix. Apply this matrix to a homongeneous vector (x,y,1) to rotate it.\r\n  @rotateAnchor2D: ( radian, anchor, axis=Const.xy ) ->\r\n    a = anchor.get2D( axis )\r\n    cosA = Math.cos( radian )\r\n    sinA = Math.sin( radian )\r\n    return [\r\n      cosA, sinA, 0\r\n      -sinA, cosA, 0\r\n      a.x*(1-cosA) + a.y*sinA, a.y*(1-cosA)-a.x*sinA, 1\r\n    ]\r\n\r\n\r\n  # ## Get a 3x3 matrix to reflect a point along a line. See also `Line.reflect()` for a potentially simpler calculation\r\n  # @param `line` the path to define the reflection\r\n  # @return an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.\r\n  @reflectAnchor2D: ( line, axis=Const.xy ) ->\r\n    inc = line.intercept( axis )\r\n    ang2 = Math.atan( inc.slope ) * 2\r\n    cosA = Math.cos( ang2 )\r\n    sinA = Math.sin( ang2 )\r\n    return [\r\n      cosA, sinA, 0\r\n      sinA, -cosA, 0\r\n      -inc.yi*sinA, inc.yi + inc.yi*cosA, 1\r\n    ]\r\n\r\n\r\n  # ## Get a 3x3 matrix for 2D shear from an anchor point\r\n  # @param `sx, sy` shear scale values, usually between -1 to 1, where 0 means no change in shear.\r\n  # @param `anchor` anchor point of shearing\r\n  # @return an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.\r\n  @shearAnchor2D: (sx, sy, anchor, axis=Const.xy  ) ->\r\n    a = anchor.get2D( axis )\r\n    tx = Math.tan( sx )\r\n    ty = Math.tan( sy )\r\n\r\n    return [\r\n      1, tx, 0\r\n      ty, 1, 0\r\n      -a.y*ty, -a.x*tx, 1\r\n    ]\r\n\r\n\r\n  # ## Get a 3x3 matrix for 2D scale from an anchor point\r\n  # @param `sx, sy` horizontal and vertical scale values, which are usually between 0 to N, where 1 means no change in scale.\r\n  # @param `anchor` anchor point of scaling\r\n  # @return an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.\r\n  @scaleAnchor2D: (sx, sy, anchor, axis=Const.xy ) ->\r\n    a = anchor.get2D( axis )\r\n    return [\r\n      sx, 0, 0,\r\n      0, sy, 0,\r\n      -a.x*sx + a.x, -a.y*sy + a.y, 1\r\n    ]\r\n\r\n\r\n  # ## Get a 3x3 scale matrix\r\n  # @param `x, y` horizontal and vertical scale values, which are usually between 0 to N, where 1 means no change in scale.\r\n  # @return an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.\r\n  @scale2D: ( x, y ) ->\r\n    return [\r\n      x, 0, 0,\r\n      0, y, 0,\r\n      0, 0, 1\r\n    ]\r\n\r\n\r\n  # ## Get a 3x3 shear matrix\r\n  # @param `x, y` shear scale values, usually between -1 to 1, where 0 means no change in shear.\r\n  # @return an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.\r\n  @shear2D: (x, y ) ->\r\n    return [\r\n      1, Math.tan(x), 0\r\n      Math.tan(y), 1, 0\r\n      0, 0, 1\r\n    ]\r\n\r\n  # ## Get a 3x3 rotate matrix\r\n  # @param `cosA, sinA` cosine and sine of the rotation angle.\r\n  # @return an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.\r\n  @rotate2D: ( cosA, sinA ) ->\r\n    return [\r\n      cosA, sinA, 0,\r\n      -sinA, cosA, 0,\r\n      0, 0, 1\r\n    ]\r\n\r\n\r\n  # ## Get a 3x3 translate matrix.\r\n  # @param `x, y` horizontal and vertical offsets to move by\r\n  # @return an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.\r\n  @translate2D: ( x, y ) ->\r\n    return [\r\n      1, 0, 0\r\n      0, 1, 0\r\n      x, y, 1\r\n    ]\r\n\r\n\r\n  # ## Calculate a 2D transform by applying matrix to a homogeneous vector\r\n  # @param `pt` a Point to transform\r\n  # @param `m` an array representing 3x3 matrix\r\n  # @param `byValue` a boolean value to update the values of `pt` parameter directly if set to true. If false, returns a new Vector object instead. Default is false.\r\n  # @return a Vector object, or the `pt` object if `byValue` is true\r\n  @transform2D: (pt, m, axis=Const.xy, byValue=false) ->\r\n    v = pt.get2D( axis )\r\n    x = v.x * m[0] + v.y * m[3] + m[6];\r\n    y = v.x * m[1] + v.y * m[4] + m[7];\r\n    # z = v.x * m[2] + v.y * m[5] + m[8];\r\n    v.x = x\r\n    v.y = y\r\n    # v.z = z\r\n    v = v.get2D(axis, true)\r\n\r\n    if !byValue\r\n      pt.set(v)\r\n      return pt\r\n\r\n    return v\r\n\r\n\r\n# namescope\r\nthis.Matrix = Matrix"]}