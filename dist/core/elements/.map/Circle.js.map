{"version":3,"sources":["Circle.coffee"],"names":[],"mappings":"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","file":"Circle.js","sourceRoot":"/source/","sourcesContent":["# ### A circle\r\nclass Circle extends Vector\r\n\r\n  # ## Create a new Circle. A Circle is a Vector which defines its center position, with a `radius` property to define its radius.\r\n  # @param `args` Similar to Point constructor, use comma-separated values, an array, or a Point object as parameters to specify the center of circle. Optionally include a 4th parameter to set the radius directly, or use `setRadius()` afterwards.\r\n  # @eg `new Circle()` `new Circle(1,2,3)` `new Circle(1,2,3,100)`\r\n  # @return a new Circle object\r\n  constructor: () ->\r\n    super\r\n\r\n    # ## the radius property\r\n    @radius = if arguments[3]? then arguments[3] else 0 # radius as 4th argument\r\n\r\n  # ## set radius of the circle\r\n  # @param `r` radius value\r\n  # @return this Circle\r\n  setRadius: ( r ) ->\r\n    @radius = r\r\n    return @\r\n\r\n\r\n  # ## Check if a point is on this Circle on xy axis.\r\n  # @param `args` comma-separated values, or an array, or a Point object\r\n  # @eg `circle.intersectPoint(1,2,3)` `circle.intersectPoint(pt)`\r\n  # @return a boolean value to indicate if there is an intersection\r\n  intersectPoint: (args) ->\r\n    item = new Vector( Point.get(arguments) )\r\n    d = item.$subtract( @ )\r\n    return (d.x * d.x + d.y * d.y <  @radius * @radius )\r\n\r\n\r\n  # ## Check intersections between this Circle and an infinite Line on xy axis. Based on [this algorithm](http://stackoverflow.com/questions/13053061/circle-line-intersection-points).\r\n  # @param `path` a Pair or Line object to specify an infinite line\r\n  # @get_pts `get_pts` a boolean value to specify whether the results should include the intersection points. If `false`, then only the intersection state (true or false) will be returned.\r\n  # @returns an Array of intersection points (zero, one, or two points), or a boolean value. (Based on `get_pts` parameter)\r\n  intersectPath: ( path, get_pts=true ) ->\r\n    if not path instanceof Pair then return false\r\n\r\n    d = path.direction()\r\n    f = @.$subtract( path )\r\n\r\n    a = d.dot(d, Const.xy)\r\n    b = f.dot(d, Const.xy)\r\n    c = f.dot(f, Const.xy) - ( @radius * @radius )\r\n    p = b / a\r\n    q = c / a\r\n    disc = p * p - q # discriminant\r\n\r\n    if disc < 0\r\n      return (if get_pts then [] else false)\r\n    else\r\n      if !get_pts then return true\r\n\r\n      discSqrt = Math.sqrt( disc )\r\n      t1 = -p + discSqrt\r\n      t2 = -p - discSqrt\r\n\r\n      p1 = new Point( path.x - d.x * t1, path.y - d.y * t1 )\r\n      p2 = new Point( path.x - d.x * t2, path.y - d.y * t2 )\r\n\r\n      return if disc == 0 then [p1] else [p1, p2]\r\n\r\n\r\n#    a = d.x * d.x + d.y * d.y\r\n#    b = d.x * f.x + d.y * f.y\r\n#    c = ( f.x * f.x + f.y * f.y ) - ( @radius * @radius )\r\n#    p = b / a\r\n#    q = c / a\r\n#    disc = p * p - q\r\n#\r\n#    if disc < 0\r\n#      return []\r\n#    else\r\n#      discSqrt = Math.sqrt( disc )\r\n#      t1 = -p + discSqrt\r\n#      t2 = -p - discSqrt\r\n#\r\n#      p1 = new Point( ray.x - d.x * t1, ray.y - d.y * t1 )\r\n#      p2 = new Point( ray.x - d.x * t2, ray.y - d.y * t2 )\r\n#\r\n#      return if disc == 0 then [p1] else [p1, p2]\r\n\r\n\r\n  # ## Check intersections between this Circle and a Line segment on xy axis.\r\n  # @param `line` a Pair or Line object to specify a line segment\r\n  # @get_pts `get_pts` a boolean value to specify whether the results should include the intersection points. If `false`, then only the intersection state (true or false) will be returned.\r\n  # @returns an Array of intersection points (zero, one, or two points), or a boolean value. (Based on `get_pts` parameter)\r\n  intersectLine: ( line, get_pts=true ) ->\r\n\r\n    # check ray\r\n    pts = @intersectPath( line )\r\n    if pts and pts.length > 0\r\n\r\n      # check intersected point is within line bounding box\r\n      pi = []\r\n      bounds = line.bounds()\r\n      for p in pts\r\n        if Rectangle.contain( p, bounds, bounds.p1 )\r\n          if !get_pts then return true\r\n          pi.push( p )\r\n\r\n      return (if get_pts then pi else (pi.length>0) )\r\n    else\r\n      return (if get_pts then [] else false)\r\n\r\n\r\n  # ## Check if this cirlce intersects with a set of lines ( useful for polygon or polyline such as `rectangle.sides()` ) on xy axis.\r\n  # @param `lines` an array of Line\r\n  # @get_pts `get_pts` a boolean value to specify whether the results should include the intersection points. If `false`, then only the intersection state (true or false) will be returned.\r\n  # @eg `circle.intersectLines( rect.sides() )` `circle.intersectLines( pointset.sides(), true )`\r\n  # @returns an Array of intersection points, or a boolean value. (Based on `get_pts` parameter)\r\n  intersectLines: (lines, get_pts=true) ->\r\n    return Line.intersectLines( @, lines, get_pts )\r\n\r\n\r\n  # ## Check if this circle intersects with another circle\r\n  # @param `circle` another Circle\r\n  # @get_pts `get_pts` a boolean value to specify whether the results should include the intersection points. If `false`, then only the intersection state (true or false) will be returned.\r\n  # @returns an Array of intersection points (zero or two points) or a boolean value, based on `get_pts` parameter.\r\n  intersectCircle: (circle, get_pts=true) ->\r\n    dv = circle.$subtract( @ )\r\n    dr2 = dv.magnitude(false)\r\n    dr = Math.sqrt( dr2 )\r\n\r\n    ca_r2 = @radius * @radius\r\n    cb_r2 = circle.radius * circle.radius\r\n\r\n    if dr > @radius + circle.radius # not intersected\r\n      return (if get_pts then [] else false)\r\n\r\n    else if dr < Math.abs( @radius - circle.radius ) # completely enclosing the other, no intersecting points\r\n      return (if get_pts then [ new Vector(this), new Vector(circle) ] else true)\r\n\r\n    else # has two intersection points\r\n      if !get_pts then return true\r\n\r\n      a = (ca_r2 - cb_r2 + dr2) / (2*dr)\r\n      h = Math.sqrt( ca_r2 - a*a )\r\n      p = dv.$multiply(a/dr).add(@)\r\n\r\n      return [\r\n        new Vector( (p.x + h*dv.y/dr), (p.y - h*dv.x/dr) )\r\n        new Vector( (p.x - h*dv.y/dr), (p.y + h*dv.x/dr) )\r\n      ]\r\n\r\n\r\n  # ## Check if this cirlce intersect with another element on xy axis\r\n  # @param `item` any object that is based on Point. (Vector, Line, Rectangle, Circle, etc)\r\n  # @eg `circle.hasIntersect( another_circle )` `circle.hasIntersect(line)` `circle.hasIntersect(rect)`\r\n  # @returns an Array of intersection points or a boolean value. (Based on `get_pts` parameter)\r\n  hasIntersect: (item, get_pts=false) ->\r\n\r\n    # circle intersection check\r\n    if item instanceof Circle\r\n      return @intersectCircle( item, get_pts )\r\n\r\n    # polygon intersection check (TODO any better algorithm?)\r\n    else if item instanceof Rectangle or item instanceof PointSet or item instanceof Triangle\r\n      return @intersectLines(item.sides(), get_pts)\r\n\r\n    # line intersection check\r\n    else if item instanceof Pair\r\n      ins = @intersectLine(item)\r\n      return if !get_pts then (ins.length > 0) else ins\r\n\r\n    # point intersection check\r\n    else if item instanceof Point\r\n      d = item.$subtract( @ )\r\n      return (d.x * d.x + d.y * d.y < @radius * @radius)\r\n\r\n    else\r\n      return if get_pts then [] else false\r\n\r\n\r\n# namespace\r\nthis.Circle = Circle"]}