{"version":3,"sources":["Util.coffee"],"names":[],"mappings":"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","file":"Util.js","sourceRoot":"/source/","sourcesContent":["# # Various static methods and helper classes\r\nclass Util\r\n\r\n  # ## A static function to convert degrees to radian\r\n  # @param `degree` angle in degrees. ie, 180 degrees = Math.PI radian\r\n  @toRadian : ( angle ) -> angle * Const.deg_to_rad\r\n\r\n\r\n  # ## A static function to convert radian to degrees\r\n  # @param `radian` angle in radian. ie, Math.PI radian = 180 degrees\r\n  @toDegree : ( radian ) -> radian * Const.rad_to_deg\r\n\r\n\r\n  # ## A static function to convert a color value (0-255) to hex \"FF\". See also `Color.hex()` and `Color.rgba()`\r\n  # @param `number` a value between 0 to 255\r\n  # @return a string with 2 hex digits, such as \"FF\" or \"00\"\r\n  @toHexColor: (number) ->\r\n    h = Math.floor(number).toString(16)\r\n    return if h.length is 1 then \"0\"+h else h\r\n\r\n\r\n  # ## A static function to convert a hex string to rgb value or string. See also `Color.parseHex()`\r\n  # @param hexString hex string such as \"FF9900\" or \"#FF9900\"\r\n  # @param asRGBA a boolean value to set if the return value should be `rgba(...)` string\r\n  # @param opacity optional opacity value between 0 to 1 for `rgba(...)` output\r\n  # @eg `Util.toRGBColor(\"\")`\r\n  @toRGBColor: (hexString, asRGBA=false, opacity=1) ->\r\n    if hexString[0] == \"#\" then hexString = hexString.substr(1)\r\n\r\n    if hexString.length == 3\r\n      r = parseInt( hexString[0]+hexString[0], 16 )\r\n      g = parseInt( hexString[1]+hexString[1], 16 )\r\n      b = parseInt( hexString[2]+hexString[2], 16 )\r\n    else if hexString.length >= 6\r\n      r = parseInt( hexString[0]+hexString[1], 16 )\r\n      g = parseInt( hexString[2]+hexString[3], 16 )\r\n      b = parseInt( hexString[4]+hexString[5], 16 )\r\n    else\r\n      r = 0\r\n      g = 0\r\n      b = 0\r\n\r\n    return if asRGBA then \"rgba(#{r},#{g},#{b},#{opacity})\" else [r,g,b,opacity]\r\n\r\n\r\n  # ## A static function to limit a value (such as an angle, can be negative) as the modulus between 0 to max, or between -max/2 to max/2\r\n  # @param `val` the value to be bound\r\n  # @param `max` maximum value as boundary\r\n  # @param `positive` a boolean value. If set to `true`, the return value will be between 0 to max; if `false`, return value will be between -max/2 to max/2. Default is `false`.\r\n  # @return a value either (0 to max) or (-max/2 to max/2)\r\n  @bound : ( val, max, positive=false ) ->\r\n    a = val % max\r\n    half = max / 2\r\n\r\n    if a>half\r\n      a -= max\r\n    else if a < -half\r\n      a += max\r\n\r\n    if positive\r\n      if a<0 then return a+max else return a\r\n    else\r\n      return a\r\n\r\n\r\n  # ## A static function to limit an angle\r\n  # @param `ang` an angle to be bound\r\n  # @param `positive` a boolean value. If set to `true`, the return value will be between 0 to max; if `false`, return value will be between -max/2 to max/2. Default is `false`.\r\n  # @return an angle either between 0 to 360, or between -180 to 180 degrees\r\n  @boundAngle : ( ang, positive ) ->\r\n    Util.bound( ang, 360, positive)\r\n\r\n\r\n  # ## A static function similar to `Util.boundAngle` but limit a radian angle between 0 to 2*PI, or between -PI to PI\r\n  @boundRadian : ( radian, positive ) ->\r\n    Util.bound( radian, Const.two_pi, positive )\r\n\r\n\r\n  # ## A static function to get a bounding box for a list of points\r\n  # @param `points` an array of points\r\n  # @param `is3D` a boolean value to specify if the points are 3D. Default is false which means the points are 2D.\r\n  # @return an Rectangle object as bounding box\r\n  @boundingBox: ( points, is3D=false ) ->\r\n    minPt = new Point( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY)\r\n    maxPt = new Point( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY)\r\n    for p in points\r\n      if p.x < minPt.x then minPt.x = p.x\r\n      if p.y < minPt.y then minPt.y = p.y\r\n      if p.x > maxPt.x then maxPt.x = p.x\r\n      if p.y > maxPt.y then maxPt.y = p.y\r\n\r\n      if is3D\r\n        if p.z < minPt.z then minPt.z = p.z\r\n        if p.z > maxPt.z then maxPt.z = p.z\r\n\r\n    return new Rectangle( minPt ).to( maxPt )\r\n\r\n\r\n  # ## A static function to get linear interpolation between two values\r\n  # @param `a, b` first and second values\r\n  # @param `t` a value between 0 to 1\r\n  # return the interpolated value\r\n  @lerp: ( a, b, t ) -> return (1-t) * a + t * b\r\n\r\n\r\n  # ## Get a centroid point which is the averge positions of a list of points.\r\n  # @param `points` an array of points\r\n  # @return the centroid point as Vector\r\n  @centroid: (points) ->\r\n      c = new Vector()\r\n      for p in points\r\n        c.add( p )\r\n      return c.divide( points.length )\r\n\r\n\r\n  # ## Check if two numbers are equal within a threshold\r\n  # @param `a, b` two numbers to compare\r\n  # @param `threshold` the smallest difference allowed to be considered as same. Default is `Const.epsilon`.\r\n  # @return a boolean value where `true` means they are the same\r\n  @same : (a, b, threshold=Const.epsilon ) ->\r\n    ( Math.abs( a - b ) < threshold )\r\n\r\n\r\n  # ## Check is a number is within the range of two number\r\n  # @param `p` the number to check\r\n  # @param `a, b` two numbers to set the range\r\n  # @return a boolean value where `true` means the number is within range\r\n  @within: ( p, a, b) ->\r\n    return p >= Math.min(a, b) and p <= Math.max(a, b)\r\n\r\n\r\n  # ## Get a random value in between a range\r\n  # @param `a, b` two numbers to set a range. `b` is optional and defaults to 0.\r\n  # @return a random number within the range\r\n  @randomRange : (a, b=0) ->\r\n    r = if a > b then ( a - b ) else ( b - a )\r\n    return a + Math.random() * r\r\n\r\n\r\n  # ## Simple mixin implementataion\r\n  # @param `klass` the class to inject\r\n  # @param `mix` is the source mixin object\r\n  # @return the klass with mixin\r\n  @mixin : ( klass, mix ) ->\r\n    for k,v of mix\r\n      if mix.hasOwnProperty( k )\r\n        klass.prototype[k] = mix[k]\r\n    return klass\r\n\r\n\r\n  # ## A helper function to extend a class\r\n  # @param `klass` constructor function\r\n  # @param `parent` class to inherit\r\n  # @eg `function V() { Vector.call(this, arguments); }; Util.extend(V, Vector);`\r\n  # @return the extended class\r\n  @extend: (klass, parent) ->\r\n    klass.prototype = Object.create(parent.prototype)\r\n    klass.prototype.constructor = klass\r\n    return klass\r\n\r\n\r\n  # ## Given an array of Points (eg, in results of toArray() ), return an array of the points as copy\r\n  @clonePoints: (array) -> ( p.clone() for p in array )\r\n\r\n\r\n  # ## Rotate from an origin using canvas rendering context\r\n  # @param `ctx` canvas rendering context\r\n  # @param `bound` the bounding box as Rectangle object\r\n  # @param `radian` the angle in radian to rotate\r\n  # @param `origin` an optional Point object to specify the anchor point of rotation. If origin is false or not set, the anchor is at the center of the `bound` bounding box\r\n  # @param `mask` an optional Rectangle object as mask\r\n  @contextRotateOrigin : (ctx, bound, radian, origin=false, mask) ->\r\n\r\n    size =  bound.size()\r\n\r\n    if !origin\r\n      origin = size.$multiply(0.5)\r\n      origin.add(bound)\r\n\r\n    if mask\r\n      msz = mask.size()\r\n      Form.rect(ctx, mask)\r\n      ctx.clip()\r\n\r\n    ctx.translate( origin.x, origin.y )\r\n    ctx.rotate( radian )\r\n    ctx.translate( -origin.x, -origin.y)\r\n\r\n\r\n  # ## A static function to pre-calculate a sine and cosine table. To use this, convert radian to angle as an integer, and then get table index by finding modulus `angle%360`\r\n  # @return an object with `{sin, cos}` properties.\r\n  @sinCosTable: () ->\r\n    cos = []\r\n    sin = []\r\n    for i in [0..360] by 1\r\n        cos[i] = Math.cos( i * Math.PI / 180 )\r\n        sin[i] = Math.sin( i * Math.PI / 180 )\r\n    return {sin: sin, cos: cos}\r\n\r\n\r\n  # ## A static function which check if a random number from 0 to 1 is smaller than a user defined number\r\n  # @param `p` a value between 0 to 1\r\n  # @return a boolean value where true means a random number is smaller than the supplied parameter\r\n  @chance: (p) -> return (Math.random() < p);\r\n\r\n\r\n  # ## A static function to calculate Gaussian curve\r\n  @gaussian: (x, mean=0, sigma=1) ->\r\n    x = (x - mean) / sigma\r\n    return Const.gaussian * Math.exp( -0.5 * x * x) / sigma\r\n\r\n\r\n# namespace\r\nthis.Util = Util;\r\n\r\n\r\n    #    for i in [0...candidateCount]\r\n#      p = new Vector( bound.x + size.x * Math.random(), bound.y + size.y * Math.random() )\r\n#      candidates.push( {\r\n#        pt: p\r\n#        inner: new Rectangle( p.x-size.x/4, p.y-size.y/4).size( size.x/2, size.y/2 )\r\n#      })\r\n#\r\n#    best = null\r\n#    for c in candidates\r\n#      matches = (it for it in items when c.inner.intersectPoint( it ))\r\n##\r\n##        if matches.length == 0\r\n##          matches = (it for it in items when !c.inner.intersectPoint( it ))\r\n##\r\n#\r\n#\r\n#      if matches.length == 0\r\n#        best = c\r\n#\r\n#      _dist = -1\r\n#\r\n#      for w in matches\r\n#        dx = (w.x-c.pt.x)\r\n#        dy = (w.y-c.pt.y)\r\n#        dist = dx*dx + dy*dy\r\n#        if dist > _dist\r\n#          best = c\r\n#          _dist = dist\r\n\r\n#    return best\r\n\r\n\r\n\r\n\r\n#  @RK4Velocity: (c1, d1, func, dt, t) ->\r\n#\r\n#    a1 = func( c1, d1, 0, t)\r\n#\r\n#    c2 = _map( c1, d1, 0.5 )\r\n#    d2 = _map( d1, a1, 0.5 )\r\n#    a2 = func( c2, d2, dt/2, t)\r\n#\r\n#    c3 = _map( c1, d2, 0.5 )\r\n#    d3 = _map( d1, a2, 0.5 )\r\n#    a3 = func( c3, d3, dt/2, t)\r\n#\r\n#    c4 = _map( c1, d3, 1 )\r\n#    d4 = _map( d1, a3, 1 )\r\n#\r\n#    dc_dt = _map2( c1, c2, c3, c4).multiply( dt )\r\n#    dd_dt = _map2( d1, d2, d3, d4).multiply( dt )\r\n#\r\n#    _map = ( mc, md, f) ->\r\n#      new Vector(\r\n#        mc.x + f * md.x * dt,\r\n#        mc.y + f * md.y * dt,\r\n#        mc.z + f * md.z * dt\r\n#      )\r\n#\r\n#    _map2 = (m1, m2, m3, m4) ->\r\n#      new Vector(\r\n#        (m1.x + 2*(m2.x+m3.x) + m4.x) / 6\r\n#        (m1.y + 2*(m2.y+m3.y) + m4.y) / 6\r\n#        (m1.z + 2*(m2.z+m3.z) + m4.z) / 6\r\n#      )\r\n#\r\n#    return { c: dc_dt.add( c1 ), d: dd_dt.add( d1 ) }\r\n\r\n#  @RK4Particle: (p dt, t) ->\r\n#\r\n#    a1 = func( c1, d1, 0, t)\r\n#\r\n#    c2 = _map( c1, d1, 0.5 )\r\n#    d2 = _map( d1, a1, 0.5 )\r\n#    a2 = func( c2, d2, dt/2, t)\r\n#\r\n#    c3 = _map( c1, d2, 0.5 )\r\n#    d3 = _map( d1, a2, 0.5 )\r\n#    a3 = func( c3, d3, dt/2, t)\r\n#\r\n#    c4 = _map( c1, d3, 1 )\r\n#    d4 = _map( d1, a3, 1 )\r\n#\r\n#    dc_dt = _map2( c1, c2, c3, c4).multiply( dt )\r\n#    dd_dt = _map2( d1, d2, d3, d4).multiply( dt )\r\n#\r\n#    _map = ( mc, md, f) ->\r\n#      new Vector(\r\n#        mc.x + f * md.x * dt,\r\n#        mc.y + f * md.y * dt,\r\n#        mc.z + f * md.z * dt\r\n#      )\r\n#\r\n#    _map2 = (m1, m2, m3, m4) ->\r\n#      new Vector(\r\n#        (m1.x + 2*(m2.x+m3.x) + m4.x) / 6\r\n#        (m1.y + 2*(m2.y+m3.y) + m4.y) / 6\r\n#        (m1.z + 2*(m2.z+m3.z) + m4.z) / 6\r\n#      )\r\n#\r\n#    return { c: dc_dt.add( c1 ), d: dd_dt.add( d1 ) }\r\n\r\n#    x1 = x\r\n#    v1= v\r\n#    a1 = run(x1, v1, 0, t)\r\n#\r\n#    x2 = x.$add( v1.$multiply( dt / 2 ))\r\n#    v2 = v.$add( a1.$multiply( dt / 2 ))\r\n#    a2 = run(x2, v2, dt/2, t)\r\n#\r\n#    x3 = x.$add( v2.$multiply( dt / 2 ))\r\n#    v3 = v.$add( a2.$multiply( dt / 2 ))\r\n#    a3 = run(x3, v3, dt/2, t)\r\n#\r\n#    x4 = x.$add( v3.$multiply( dt ) )\r\n#    v4 = v.$add( a3.$multiply( dt ))\r\n#\r\n#    dxdt = x1.$add( x2.add(x3).multiply(2) ).add( x4 )\r\n#    dxdt.divide( 6 ).multiply( dt )\r\n#\r\n#    dvdt = v1.$add( v2.add(v3).multiply(2) ).add( v4 )\r\n#    dvdt.divide( 6 ).multiply( dt )\r\n#\r\n#    return { a: x.$add( dxdt ), b: v.$add( dvdt ) }\r\n\r\n\r\n  # ## Modified Euler (adopted from traer physics library)\r\n  # the derivative of c is d. If c is position, then d is velocity.\r\n  # dt = change in time, t = current time\r\n  # run = acceleration function(x, v, dt)\r\n#  @integrateEuler: (c, d, func, dt, t) ->\r\n#\r\n#    tt = 0.5*dt*dt\r\n#    a = func( c, d, dt, t)\r\n#\r\n#    c += d/dt\r\n#    c += a * tt\r\n#    d += a/dt\r\n#\r\n#    return { c: c, d: d }\r\n\r\n\r\n\r\n\r\n# namespace\r\nthis.Util = Util"]}