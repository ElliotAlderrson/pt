{"version":3,"sources":["Pair.coffee"],"names":[],"mappings":"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","file":"Pair.js","sourceRoot":"/source/","sourcesContent":["# ### A Pair of Vector\r\nclass Pair extends Vector\r\n\r\n  # ## Create a new Pair. A Pair is a Vector which defines its anchor point, and connected to another Vector through the `to()` function.\r\n  # @param `args` Similar to Point constructor, use comma-separated values, an array, or an object as parameters to specify the first point. As a shortcut to `to()`, you can also pass 4 or 6 values to set both anchor and `p1` points directly as a 2d or 3d vector.\r\n  # @eg `new Pair()` `new Pair(1,2,3)` `new Pair([2,4])` `new Pair({x:3, y:6, z:9}).to(1,2,3)`, `new Pair(10,10, 20,20)`\r\n  # @return a new Pair object\r\n  constructor: () ->\r\n    super\r\n\r\n    # ## A vector object which is other point in this pair.\r\n    @p1 = new Vector( @x, @y, @z )\r\n\r\n    if arguments.length == 4\r\n      @z = 0\r\n      @p1.set( arguments[2], arguments[3] )\r\n    else if arguments.length == 6\r\n      @p1.set( arguments[3], arguments[4], arguments[5] )\r\n\r\n\r\n  # ## connect the other point\r\n  # @param `args` comma-separated values, or an array, or an object\r\n  # @eg `pair.to(1,2,3)` `new Pair(1,2).to(3,4)`\r\n  # @return this Pair\r\n  to: () ->\r\n    @p1 = new Vector( Point.get(arguments) )\r\n    return @\r\n\r\n  # ## Update p1's new position by recalculating it as a relative position to the anchor point\r\n  # @return this Pair\r\n  relative: () ->\r\n    @p1.add( @ )\r\n    return @\r\n\r\n  # ## Return a new vector of p1's new position, by recalculating it as a relative position to the anchor point\r\n  # @return a new Vector\r\n  $relative: () -> @$add( @p1 )\r\n\r\n\r\n  # ## Get a new pair that's the bounding box of this pair. This is the same as calculating its top-left (min) and bottom-right (max) points.\r\n  # @return a new Pair\r\n  bounds: () ->\r\n    return new Pair( @min(@p1) ).to( @max(@p1) )\r\n\r\n  # ## Check if a point is within the bounds of this pair\r\n  # @param `pt` a Point object to check.\r\n  # @param `axis` optional axis id such as Const.xy.\r\n  # @eg `pair.withinBounds( point )`, `pair.withinBounds( point, Const.yz )`\r\n  # @return a boolean value where `true` means the point is within bounds.\r\n  withinBounds: ( pt, axis ) ->\r\n    if axis\r\n      a = @get2D( axis )\r\n      b = @p1.get2D( axis )\r\n\r\n      # simplify checking for horizontal and vertical lines, and avoid rounding errors\r\n      if a.x == b.x\r\n        return pt.y >= Math.min(a.y, b.y) and pt.y <= Math.max(a.y, b.y)\r\n      else if a.y == b.y\r\n        return pt.x >= Math.min(a.x, b.x) and pt.x <= Math.max(a.x, b.x)\r\n\r\n      # bounding box check\r\n      else\r\n        return ( pt.x >= Math.min(a.x, b.x) and pt.y >= Math.min(a.y, b.y) and pt.x <= Math.max(a.x, b.x) and pt.y <= Math.max(a.y, b.y) )\r\n    else\r\n      return ( pt.x >= Math.min( @x, @p1.x) and pt.y >= Math.min(@y, @p1.y) and pt.z >= Math.min(@z, @p1.z) and pt.x <= Math.max(@x, @p1.x) and pt.y <= Math.max(@y, @p1.y) and pt.z <= Math.max(@z, @p1.z) )\r\n\r\n  # ## Interpolate to find a point which lies somewhere on a straight path between the two points of this pair\r\n  # @param `t` a value between 0 to 1.\r\n  # @param `relative` an optional boolean value. If `true`, then `this.p1` will be treated as relative to the achor point. Default is `false`.\r\n  # @eg `pair.interpolate(0.4)` `pair.interpolate(0.1, true)`\r\n  # @return the interpolated point as Vector\r\n  interpolate: ( t, relative=false ) ->\r\n    p2 = if relative then @$relative() else @p1\r\n\r\n    return new Vector(\r\n      (1-t) * @x + t * p2.x\r\n      (1-t) * @y + t * p2.y\r\n      (1-t) * @z + t * p2.z\r\n    )\r\n\r\n  # ## A convenient method to get the midpoint of this pair of points. Same as @interpolate( 0.5 )\r\n  # @return the middle point as Vector\r\n  midpoint: () -> @interpolate( 0.5 )\r\n\r\n  # ## Get a vector which points to the same direction as this pair, but starts at origin (0,0)\r\n  # @param `reverse` optional parameter to reverse the direction if set to `true`. Default is `false`.\r\n  # @eg `pair.direction()`, `pair.direction(false)`, `pair.direction().normalize()`\r\n  # @return the directional vector\r\n  direction: ( reverse ) ->\r\n    return if reverse then @.$subtract( @p1 ) else @p1.$subtract( @ )\r\n\r\n\r\n  # ## Set or get width and height of this pair\r\n  # @param `args` Optional parameter to set the size of this Pair. Can be comma-separated values, or as an array, or a Point object.\r\n  # @eg `pair.size()`, `pair.size(100, 50)`\r\n  # @return When setting a new size, returns self. When getting size, returns a Vector whose x is the width and y is the height.\r\n  size: () ->\r\n    if arguments.length > 0\r\n      @p1 = @.$add( Point.get(arguments) )\r\n      return @\r\n    else\r\n      return @p1.$subtract( @ ).abs()\r\n\r\n  # ## Find distance of this pair from anchor to p1\r\n  # @param: `sqrt` optional boolean value to get distance-squared value if set to `false`. Default is true.\r\n  # @return distance value\r\n  length: ( sqrt = true ) ->\r\n    dz = @z - @p1.z\r\n    dy = @y - @p1.y;\r\n    dx = @x - @p1.x;\r\n    d = dx*dx + dy*dy + dz*dz\r\n    return if sqrt then Math.sqrt( d ) else d\r\n\r\n\r\n  # ## Check if a point lies on the left or right side of this pair's *ray*, and if the 3 points are collinear\r\n  # @param `point` a Point object to check against this pair.\r\n  # @return a value where 0 means collinear, poitive value means the point lies on left, and negative value means it's on right\r\n  collinear: (point) ->\r\n    return (@p1.x - @x) * (point.y - @y) - (point.x - @x) * (@p1.y - @y)\r\n\r\n  # ## Recalculate the origin and vec so that origin is at top-left and vec is at bottom-right\r\n  # @return this Pair\r\n  resetBounds: () ->\r\n    temp = @min( @p1 )\r\n    @p1.set( @max( @p1 ) )\r\n    @set( temp )\r\n    return @\r\n\r\n  # ## override equal() from parent class\r\n  equal: (epsilon=false) ->\r\n    if arguments[0] instanceof Pair\r\n      return super( arguments[0] ) and @p1.equal( arguments[0].p1 )\r\n    else\r\n      super\r\n\r\n  # ## Override clone() from parent class\r\n  clone: () ->\r\n    p = new Pair( @ )\r\n    p.to( @p1.clone() )\r\n    return p\r\n\r\n  # ## Override floor() from parent class\r\n  floor: () ->\r\n    super\r\n    @p1.floor()\r\n\r\n  # ## Describe this Pair as a text string\r\n  # @return \"Pair of vectors from ... to ...\" text\r\n  toString: () -> \"Pair of vectors from (#{ @x }, #{ @y }, #{ @z }) to (#{ @p1.x }, #{ @p1.y }, #{ @p1.z })\"\r\n\r\n  # ## Override toArray() include `p1` in the array.\r\n  toArray: () -> [@, @p1]\r\n\r\n\r\n# namespace\r\nthis.Pair = Pair"]}