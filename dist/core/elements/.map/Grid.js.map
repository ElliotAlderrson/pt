{"version":3,"sources":["Grid.coffee"],"names":[],"mappings":"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","file":"Grid.js","sourceRoot":"/source/","sourcesContent":["# ### Basic Grid implementation\r\nclass Grid extends Rectangle\r\n\r\n  # ## Create a new Grid. Like a Rectangle, a Grid's area are defined by two Vectors.\r\n  # @param `args` Similar to Pair constructor, use comma-separated values, an array, or an object as parameters to specify the first point. As a shortcut to `to()`, you can also pass 4 or 6 values to set both anchor and `p1` points directly as a 2d or 3d vector.\r\n  # @eg `new Grid()` `new Grid(1,2,3)` `new Grid([2,4])` `new Grid({x:3, y:6, z:9}).to(1,2,3)`\r\n  # @return a new Grid object\r\n  constructor: () ->\r\n    super\r\n\r\n    # ## grid cell settings as an object with `.type` property which defines the grid type such as \"fix-fix\", and `.size` property which stores the cell size as a Vector object.\r\n    @cell = {\r\n      type : 'fix-fix'\r\n      size: new Vector()\r\n    }\r\n\r\n    # ## property to specify number of rows in the grid\r\n    @rows = 0\r\n\r\n    # ## property to specify number of columns in the grid\r\n    @columns = 0\r\n\r\n    # ## property to store layout and cell states\r\n    @layout = []\r\n\r\n    # callback from cell generation\r\n    @cellCallback = null\r\n\r\n\r\n  # ## Describe this grid as a text string\r\n  # @return \"Grid width, height, columns, rows, cell\" text\r\n  toString: ->\r\n    s = @size()\r\n    \"Grid width #{s.x}, height #{s.y}, columns #{@columns}, rows #{@rows}, \" +\r\n    \"cell (#{@cell.size.x}, #{@cell.size.y}), type #{@cell.type}\"\r\n\r\n\r\n  # ## Initiate a grid\r\n  # @param `x` a value to specify cell width (if `xtype` parameter is \"fix\" or \"flex\") or column count  (if `xtype` parameter is \"stretch\")\r\n  # @param `y` a value to specify cell height (if `ytype` parameter is \"fix\" or \"flex\") or row count (if `ytype` parameter is \"stretch\")\r\n  # @param `xtype, ytype` a string to specify how columns and rows should be calculated. Use \"fix\" to specify exact cell width or height in pixels, \"flex\" to specify ideal cell width or height in pixels (which allows for flexible rounding to rows or columns), \"stretch\" to specify number of rows or columns only\r\n  # @eg `grid.create(100,50)` `grid.create( 10,10, \"stretch\",\"stretch\")` `grid.create( 20,20, \"flex\",\"fix\")`\r\n  # @return this grid\r\n  init : ( x, y, xtype='fix', ytype='fix' ) ->\r\n\r\n    size = @size()\r\n\r\n    @cell.type = xtype + '-' + ytype\r\n    @rows = y\r\n    @columns = x\r\n\r\n    # calculate x and columns\r\n    # stretch: always fit number of columns\r\n    if xtype is 'stretch'\r\n      @cell.size.x = size.x / x\r\n      @columns = x\r\n    # flex: fit as many as possible\r\n    else if xtype is 'flex'\r\n      @columns = Math.round( size.x / x )\r\n      @cell.size.x =size.x / @columns\r\n    # fix: cell width is fixed\r\n    else # fix\r\n      @cell.size.x = x\r\n      @columns = Math.floor( size.x / @cell.size.x )\r\n\r\n    # calculate y and rows\r\n    # stretch: always fit number of rows\r\n    if ytype is 'stretch'\r\n      @cell.size.y = size.y / y\r\n      @rows = y\r\n    # flex: fit as many as possible\r\n    else if ytype is 'flex'\r\n      @rows = Math.round( size.y / y )\r\n      @cell.size.y = size.y / @rows\r\n    # fix: cell height is fixed\r\n    else # fix\r\n      @cell.size.y = y\r\n      @rows = Math.floor( size.y / @cell.size.y )\r\n\r\n    return @\r\n\r\n\r\n  # ##  Define a callback function for cell creation. This will loop through each cell in the grid and call the callback function.\r\n  # @param `callback` a callback function with these parameters `( cell_size, cell_position, cell_row, cell_column, cell_type )`\r\n  # @return this grid\r\n  generate : ( callback ) ->\r\n    if (typeof callback == \"function\")\r\n      @cellCallback = callback\r\n    return @\r\n\r\n\r\n  # ## Generate the grid by looping through each cell\r\n  create : () ->\r\n    if !@cellCallback then return @\r\n\r\n    for c in [0...@columns]\r\n      for r in [0...@rows]\r\n        cell = @cell.size.clone()\r\n        pos = @$add( cell.$multiply( c, r ) ) # cellsize * row-column + grid-position\r\n        isOccupied = if (@layout.length > 0 and @layout[0].length > 0) then @layout[r][c]==1 else false;\r\n        @cellCallback( cell, pos, r, c, @cell.type, isOccupied )\r\n\r\n    return @\r\n\r\n\r\n  # ## Get the cell's size as a Vector\r\n  # @return a cloned `cell.size` property as Vector\r\n  getCellSize: () -> return @cell.size.clone()\r\n\r\n  # ## Give a column and a row, get a rectangle which indicates the cell position and size\r\n  # @param `c, r` column and row index, respectively\r\n  # @param `allowOutofBound` a boolean value to set if the returned rectangle can be outside of the grid\r\n  # @eg `grid.cellToRectangle(2, 3)`, `grid.cellToRectangle(2, 5, true)`\r\n  # @return a Rectangle\r\n  cellToRectangle : (c, r, allowOutofBound=false) ->\r\n    # cellsize * row-column + grid-position\r\n    if allowOutofBound or (c >= 0 and c < @columns and r >= 0 and r < @rows)\r\n      rect = new Rectangle( @$add( @cell.size.$multiply( c, r ) ) ).resizeTo( @cell.size )\r\n      return rect\r\n    else\r\n      return false\r\n\r\n\r\n  # ## Give a x,y position, get the corresponding cell on the grid.\r\n  # @param `args` 0-3 comma-separated values, or as an array, or a Point object.\r\n  # @eg `grid.positionToCell( 100, 50 )`, `grid.positionToCell( [100, 50] )`, `grid.positionToCell( pt )`,\r\n  # @return a Vector object whose `x` is the column index and `y` is the row index\r\n  positionToCell : (args) ->\r\n    pos = new Vector( @_getArgs( arguments ) )\r\n    cellpos = pos.$subtract( @ ).$divide( @cell.size ).floor()\r\n    cellpos.max( 0, 0 ).min( @columns-1, @rows-1 );\r\n    return cellpos\r\n\r\n\r\n  # ## Reset the layout and its cell states\r\n  # @param `callback` a function with these parameters ( this_grid, cell_row, cell_column ). This will get called after each cell's reset.\r\n  # @return this grid\r\n  resetLayout : ( callback ) ->\r\n    @layout = []\r\n    for r in [0...@rows]\r\n      @layout[r] = []\r\n      for c in [0...@columns]\r\n        @layout[r][c] = 0\r\n        if callback then callback( @, r, c )\r\n\r\n    return @\r\n\r\n\r\n  # ## Mark a certain area in the grid layout as occupied\r\n  # @param `x, y` column and row index\r\n  # @param `w` column width\r\n  # @param `h` row size\r\n  # @param `occupy` a boolean value to set if this cell should be occupied. Defaults to `true`\r\n  # @eg `grid.occupy(0,0, 5,3)`\r\n  # @return this grid\r\n  occupy : ( x, y, w, h, occupy=true ) ->\r\n    if (@rows <= 0 or @columns <=0) then return @\r\n    if (@layout.length < 1) then @resetLayout()\r\n    for c in [0...w]\r\n      for r in [0...h]\r\n        @layout[ Math.min( @layout.length-1, y+r) ][ x+c] = (if (occupy) then 1 else 0)\r\n\r\n    return @\r\n\r\n\r\n  # ## Check a certain area in the grid is unoccupied\r\n  # @param `x, y` column and row index\r\n  # @param `w` column width\r\n  # @param `h` row size\r\n  # @eg `grid.canFit(0,0, 5,3)`\r\n  # @return a boolean value where `true` means the area is unoccupied\r\n  canFit : ( x, y, w, h ) ->\r\n\r\n    # each cell in specific rows and columns\r\n    for currRow in [y...Math.min(@rows, y+h)]\r\n      for currCol in [x...Math.min(@columns, x+w)]\r\n        cell = @layout[currRow][currCol]\r\n        # if cell is filled\r\n        if cell? and cell > 0\r\n          return false\r\n\r\n    return true\r\n\r\n\r\n  # ## Fit this area as much as possible within the grid's free ceels\r\n  # @param `cols` number of columns\r\n  # @param `rows` number of rows\r\n  # @return an object with properties `row` and `column` to specify the top left position, `columnSize` and `rowSize` to specify the resulting size in grid units, and `bound` which is the actual area as a Rectangle object.\r\n  fit : ( cols, rows ) ->\r\n\r\n    # find column size, bound by maximum columns in the grid\r\n    # maxColumns = @layout[0].length\r\n    colSize = Math.min( cols, @columns )\r\n\r\n    # go through each grid cell\r\n    # each row\r\n    for currRow in [0...@rows]\r\n      colCount = colSize # counter to find available columns\r\n      freeCol = 0 # start position of first free column\r\n\r\n      # each column\r\n      for currCol in [0...@columns]\r\n        cell = @layout[currRow][currCol]\r\n\r\n        # if cell is filled\r\n        if cell? and cell > 0\r\n          freeCol++ # this column is not free\r\n          colCount = colSize # reset colCount if it's counting\r\n\r\n        # if cell is not filled\r\n        else\r\n          # see if the next one fits\r\n          colCount--\r\n\r\n          # can fit all\r\n          if colCount <= 0\r\n\r\n            # mark this area as occupied\r\n            @occupy( freeCol,  currRow, colSize, rows )\r\n\r\n            # calculate the bounding box\r\n            b = new Rectangle( @$add( @cell.size.$multiply( freeCol, currRow ) ) ) # top left\r\n            b.resizeTo( @cell.size.$multiply( colSize, rows ) ) # size\r\n\r\n            return {\r\n              row: currRow\r\n              column: freeCol\r\n              columnSize: colSize\r\n              rowSize: rows\r\n              bound: b\r\n            }\r\n\r\n    # cannot fit\r\n    return false\r\n\r\n\r\n  # ## Given a cell's position, get an array of the neighboring cells that surround it\r\n  # @param `c` column index\r\n  # @param `r` row index\r\n  # @eg `grid.neighbors( 3, 2 )`, `(grid.neighbors(3, 2))[Const.top_right]`\r\n  # @return an array of neighbors starting from top-left going clockwise. The array values can be Vectors whose `x` is column index and `y` is row index, or `false` if the neighbor cell is out of bounds. You may access the cells semantically by using Const.top_right etc.\r\n  neighbors: (c, r) ->\r\n    temp = [ [c-1, r-1], [c, r-1], [c+1, r-1], [c+1, r], [c+1, r+1], [c, r+1], [c-1, r+1], [c-1, r] ];\r\n    ns = []\r\n    for n in temp\r\n      if n[0] >= 0 and n[0] < @columns and n[1] >= 0 and n[1] < @rows\r\n        ns.push( new Vector( n[0], n[1], @layout[ n[1] ][ n[0] ] ) )\r\n      else\r\n        ns.push( false )\r\n    return ns;\r\n\r\n\r\n\r\n# namespace\r\nthis.Grid = Grid"]}