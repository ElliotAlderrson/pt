// Generated by CoffeeScript 1.3.1
var Easing, GridCascade, ParticleEmitter, ParticleField, QuadTree, SamplePoints, StripeBound, UI,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

StripeBound = (function(_super) {

  __extends(StripeBound, _super);

  StripeBound.name = 'StripeBound';

  function StripeBound() {
    StripeBound.__super__.constructor.apply(this, arguments);
    this.frequency = new Point();
    this.stripes = new Point();
    this.method = 'frequency';
    this.mask = null;
  }

  StripeBound.prototype.setFrequency = function(x, y) {
    this.frequency = new Vector(x, y);
    return this.method = 'frequency';
  };

  StripeBound.prototype.setStripes = function(x, y) {
    this.stripes = new Point(x, y);
    return this.method = 'stripes';
  };

  StripeBound.prototype.getStripes = function() {
    var d, diff, dx, dy, freq, p, result, size, _i, _j, _ref, _ref1;
    size = this.size();
    result = {
      columns: [],
      rows: []
    };
    freq = this.method === 'frequency' ? this.frequency.clone() : size.$divide(this.stripes).floor();
    diff = size.$divide(freq);
    for (d = _i = 0, _ref = freq.y - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; d = 0 <= _ref ? ++_i : --_i) {
      dy = diff.y * d;
      p = new Pair(0, dy).connect(size.x, dy + diff.y).add(this);
      p.p1.add(this);
      result.rows.push(p);
    }
    for (d = _j = 0, _ref1 = freq.x - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; d = 0 <= _ref1 ? ++_j : --_j) {
      dx = diff.x * d;
      p = new Pair(dx, 0).connect(dx + diff.x + 0.5, size.y).add(this);
      p.p1.add(this);
      result.columns.push(p);
    }
    return result;
  };

  StripeBound.prototype.getStripeLines = function() {
    var d, diff, dx, dy, freq, p, result, size, _i, _j, _ref, _ref1;
    size = this.size();
    result = {
      columns: [],
      rows: []
    };
    freq = this.method === 'frequency' ? this.frequency.clone() : size.$divide(this.stripes).floor();
    diff = size.$divide(freq);
    for (d = _i = 0, _ref = freq.y; 0 <= _ref ? _i <= _ref : _i >= _ref; d = 0 <= _ref ? ++_i : --_i) {
      dy = diff.y * d;
      p = new Pair(0, dy).connect(size.x, dy).add(this);
      p.p1.add(this);
      result.rows.push(p);
    }
    for (d = _j = 0, _ref1 = freq.x; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; d = 0 <= _ref1 ? ++_j : --_j) {
      dx = diff.x * d;
      p = new Pair(dx, 0).connect(dx, size.y).add(this);
      p.p1.add(this);
      result.columns.push(p);
    }
    return result;
  };

  StripeBound.prototype.setMask = function(w, h, anchor) {
    var diff, sz;
    if (anchor == null) {
      anchor = false;
    }
    this.mask = new Rectangle(this.x, this.y);
    sz = this.size();
    if (!anchor) {
      diff = sz.$subtract(w, h).divide(2);
      anchor = new Point(this.x + diff.x, this.y + diff.y);
    } else {
      anchor = this.$add(anchor);
    }
    return this.mask.set(anchor.x, anchor.y).size(w, h);
  };

  StripeBound.prototype.anchorMask = function() {
    var d;
    d = this.$subtract(this.mask);
    this.moveBy(d);
    return this.mask.moveBy(d);
  };

  return StripeBound;

})(Rectangle);

window.Pt = window.Pt || {};

Pt.StripeBound = StripeBound;

QuadTree = (function(_super) {

  __extends(QuadTree, _super);

  QuadTree.name = 'QuadTree';

  function QuadTree() {
    QuadTree.__super__.constructor.apply(this, arguments);
    this.quads = false;
    this.items = [];
    this.depth = 0;
    this.max_depth = 6;
    this.max_items = 2;
  }

  QuadTree.prototype.getQuads = function(p, list) {
    var k, q, _ref;
    if (list == null) {
      list = [];
    }
    if (this.intersectPoint(p)) {
      list.push(this);
      if (this.quads) {
        _ref = this.quads;
        for (k in _ref) {
          q = _ref[k];
          if (q.intersectPoint(p)) {
            q.getQuads(p, list);
          }
        }
      }
    }
    return list;
  };

  QuadTree.prototype.getItems = function(p) {
    var k, q, _ref;
    if (this.intersectPoint(p)) {
      if (!this.quads) {
        return this.items;
      }
      if (this.quads) {
        _ref = this.quads;
        for (k in _ref) {
          q = _ref[k];
          if (q.intersectPoint(p)) {
            return q.getItems(p);
          }
        }
      }
    }
    return [];
  };

  QuadTree.prototype.addToQuad = function(item) {
    var k, q, _depth, _ref;
    if (!item) {
      return -1;
    }
    if (this.quads) {
      _ref = this.quads;
      for (k in _ref) {
        q = _ref[k];
        _depth = q.addToQuad(item);
        if (_depth > 0) {
          return _depth;
        }
      }
      return -1;
    }
    if (!this.quads && this.intersectPoint(item)) {
      if (this.items.length >= this.max_items) {
        if (this.depth < this.max_depth) {
          this.splitQuad();
          return this.addToQuad(item);
        } else {
          return -1;
        }
      } else {
        this.items.push(item);
        return this.depth;
      }
    }
    return -1;
  };

  QuadTree.prototype.splitQuad = function() {
    var i, item, k, q, t, _depth, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
    this.quads = this.quadrants();
    _ref = this.quads;
    for (k in _ref) {
      q = _ref[k];
      q.depth = this.depth + 1;
    }
    _ref1 = this.items;
    for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
      item = _ref1[i];
      _depth = this.addToQuad(item);
      if (_depth > this.depth) {
        this.items[i] = null;
      }
    }
    _ref2 = this.items;
    _results = [];
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      t = _ref2[_j];
      if (!t) {
        _results.push(this.items.splice(t, 1));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  QuadTree.prototype.resetQuad = function() {
    var k, q, _ref;
    this.items = [];
    if (this.quads) {
      _ref = this.quads;
      for (k in _ref) {
        q = _ref[k];
        q.resetQuad();
      }
      return this.quads = false;
    }
  };

  return QuadTree;

})(Rectangle);

window.Pt = window.Pt || {};

Pt.QuadTree = QuadTree;

SamplePoints = (function(_super) {

  __extends(SamplePoints, _super);

  SamplePoints.name = 'SamplePoints';

  function SamplePoints() {
    SamplePoints.__super__.constructor.apply(this, arguments);
    this.bestcandidate = null;
    this.poisson = null;
    this.bound = null;
    this.boundsize = null;
  }

  SamplePoints.prototype.setBounds = function(b, anchor) {
    if (anchor == null) {
      anchor = false;
    }
    if (anchor) {
      this.set(b);
    }
    return this.bound = new Rectangle(this).size(b.size());
  };

  SamplePoints.prototype.bestCandidateSampler = function() {
    this.points = [];
    if (!this.bound) {
      this.bound = new Rectangle().size(500, 500);
    }
    this.boundsize = this.bound.size();
    this.bestcandidate = {
      halfsize: this.boundsize.$divide(2),
      quartersize: this.boundsize.$divide(4),
      maxDist: this.boundsize.x * this.boundsize.x + this.boundsize.y * this.boundsize.y
    };
    return this;
  };

  SamplePoints.prototype.poissonSampler = function(radius) {
    var cellsize;
    this.points = [];
    if (!this.bound) {
      this.bound = new Rectangle().size(500, 500);
    }
    this.boundsize = this.bound.size();
    cellsize = radius * Math.SQRT1_2;
    this.poisson = {
      grid: [],
      gridWidth: Math.ceil(this.boundsize.x / cellsize),
      gridHeight: Math.ceil(this.boundsize.y / cellsize),
      cellSize: cellsize,
      radius: radius,
      radius2: radius * radius,
      R: 3 * radius * radius,
      queue: [],
      queueSize: 0,
      sampleSize: 0,
      sincos: Util.sinCosTable()
    };
    return this;
  };

  SamplePoints.prototype.sample = function(numSamples, type) {
    var a, best, bestDist, i, j, nearest, p, r, s, x, y, _i, _j;
    if (numSamples == null) {
      numSamples = 10;
    }
    if (type == null) {
      type = false;
    }
    if (this.poisson && type === 'poisson') {
      if (this.poisson.sampleSize > 0 && this.poisson.queueSize === 0) {
        return false;
      }
      if (!this.poisson.sampleSize) {
        return this._poissonSample(this.bound.x + this.boundsize.x / 2, this.bound.y + this.boundsize.y / 2);
      }
      while (this.poisson.queueSize) {
        i = Math.floor(Math.random() * this.poisson.queueSize);
        s = this.poisson.queue[i];
        for (j = _i = 0; _i < numSamples; j = _i += 1) {
          a = Math.floor(360 * Math.random());
          r = Math.sqrt(Math.random() * this.poisson.R + this.poisson.radius2);
          x = s.x + r * this.poisson.sincos.cos[a];
          y = s.y + r * this.poisson.sincos.sin[a];
          if (x >= this.bound.x && x < this.boundsize.x && y >= this.bound.y && y < this.boundsize.y && this._poissonCheck(x, y)) {
            return this._poissonSample(x, y);
          }
        }
        this.poisson.queue[i] = this.poisson.queue[--this.poisson.queueSize];
        this.poisson.queue.length = this.poisson.queueSize;
      }
      return true;
    } else if (this.bestcandidate) {
      best = null;
      bestDist = -1;
      for (i = _j = 0; _j < numSamples; i = _j += 1) {
        p = new Vector(this.bound.x + this.boundsize.x * Math.random(), this.bound.y + this.boundsize.y * Math.random());
        if (this.points.length === 0) {
          best = p;
          break;
        } else {
          nearest = this._bestCandidateCheck(p);
          if (nearest > bestDist) {
            best = p;
            bestDist = nearest;
          }
        }
      }
      if (best) {
        this.points.push(best);
      }
      return best;
    }
  };

  SamplePoints.prototype._bestCandidateCheck = function(p) {
    var dist, dx, dy, halfbound, it, matches, w, _dist, _i, _len;
    _dist = this.bestcandidate.maxDist;
    halfbound = new Rectangle(p.x - this.bestcandidate.quartersize.x, p.y - this.bestcandidate.quartersize.y).size(this.bestcandidate.halfsize.x, this.bestcandidate.halfsize.y);
    matches = (function() {
      var _i, _len, _ref, _results;
      _ref = this.points;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        it = _ref[_i];
        if (halfbound.intersectPoint(it)) {
          _results.push(it);
        }
      }
      return _results;
    }).call(this);
    for (_i = 0, _len = matches.length; _i < _len; _i++) {
      w = matches[_i];
      dx = w.x - p.x;
      dy = w.y - p.y;
      dist = dx * dx + dy * dy;
      if (dist < _dist) {
        _dist = dist;
      }
    }
    return _dist;
  };

  SamplePoints.prototype._poissonSample = function(x, y) {
    var s;
    s = new Point(x, y);
    this.poisson.queue.push(s);
    this.poisson.grid[this.poisson.gridWidth * (y / this.poisson.cellSize | 0) + (x / this.poisson.cellSize | 0)] = s;
    this.poisson.sampleSize++;
    this.poisson.queueSize++;
    return s;
  };

  SamplePoints.prototype._poissonCheck = function(x, y) {
    var dx, dy, i, i0, i1, j, j0, j1, o, s, _i, _j;
    i = Math.floor(x / this.poisson.cellSize);
    j = Math.floor(y / this.poisson.cellSize);
    i0 = Math.max(i - 2, 0);
    j0 = Math.max(j - 2, 0);
    i1 = Math.min(i + 3, this.poisson.gridWidth);
    j1 = Math.min(j + 3, this.poisson.gridHeight);
    for (j = _i = j0; _i < j1; j = _i += 1) {
      o = j * this.poisson.gridWidth;
      for (i = _j = i0; _j < i1; i = _j += 1) {
        s = this.poisson.grid[o + i];
        if (s) {
          dx = s.x - x;
          dy = s.y - y;
          if (dx * dx + dy * dy < this.poisson.radius2) {
            return false;
          }
        }
      }
    }
    return true;
  };

  return SamplePoints;

})(PointSet);

UI = (function(_super) {

  __extends(UI, _super);

  UI.name = 'UI';

  UI.dragTarget = null;

  function UI() {
    UI.__super__.constructor.apply(this, arguments);
    this.dragging = false;
  }

  UI.prototype.animate = function(time, frame, ctx) {
    ctx.fillStyle = '#f00';
    return Form.rect(ctx, this);
  };

  UI.prototype.onMouseAction = function(type, x, y, evt) {
    if (this.intersectPoint(x, y)) {
      if (type === 'drag' && !UI.dragTarget) {
        this.dragging = true;
        UI.dragTarget = this;
      }
    }
    if (this.dragging && type === 'move') {
      this.moveTo(x, y).moveBy(this.size().multiply(-0.5));
    }
    if (type === 'drop') {
      this.dragging = false;
      return UI.dragTarget = null;
    }
  };

  return UI;

})(Rectangle);

Easing = (function() {

  Easing.name = 'Easing';

  function Easing() {}

  Easing.linear = function(t, b, c, d) {
    return c * (t /= d) + b;
  };

  Easing._linear = function(t) {
    return Easing.linear(t, 0, 1, 1);
  };

  Easing.quadIn = function(t, b, c, d) {
    return c * (t /= d) * t + b;
  };

  Easing._quadIn = function(t) {
    return Easing.quadIn(t, 0, 1, 1);
  };

  Easing.quadOut = function(t, b, c, d) {
    return -c * (t /= d) * (t - 2) + b;
  };

  Easing._quadOut = function(t) {
    return Easing.quadOut(t, 0, 1, 1);
  };

  Easing.cubicIn = function(t, b, c, d) {
    t = t / d;
    return c * t * t * t + b;
  };

  Easing._cubicIn = function(t) {
    return Easing.cubicIn(t, 0, 1, 1);
  };

  Easing.cubicOut = function(t, b, c, d) {
    t = t / d;
    return c * ((t - 1) * t * t + 1) + b;
  };

  Easing._cubicOut = function(t) {
    return Easing.cubicOut(t, 0, 1, 1);
  };

  Easing.elastic = function(t, b, c, d, el) {
    var a, p, s;
    if (el == null) {
      el = 0.3;
    }
    s = 1.70158;
    p = d * el;
    a = c;
    if (t === 0) {
      return b;
    }
    t = t / d;
    if (t === 1) {
      return b + c;
    }
    if (a < Math.abs(c)) {
      a = c;
      s = p / 4;
    } else if (a !== 0) {
      s = p / Const.two_pi * Math.asin(c / a);
    } else {
      s = 0;
    }
    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * Const.two_pi / p) + c + b;
  };

  Easing._elastic = function(t) {
    return Easing.elastic(t, 0, 1, 1);
  };

  Easing.bounce = function(t, b, c, d) {
    if ((t /= d) < (1 / 2.75)) {
      return c * (7.5625 * t * t) + b;
    } else if (t < (2 / 2.75)) {
      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
    } else if (t < (2.5 / 2.75)) {
      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
    } else {
      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
    }
  };

  Easing._bounce = function(t) {
    return Easing.bounce(t, 0, 1, 1);
  };

  return Easing;

})();

ParticleField = (function(_super) {

  __extends(ParticleField, _super);

  ParticleField.name = 'ParticleField';

  function ParticleField() {
    ParticleField.__super__.constructor.apply(this, arguments);
    this.system = void 0;
  }

  ParticleField.prototype.check = function(particles, removal) {
    var p, temp, _i, _len;
    if (removal == null) {
      removal = false;
    }
    temp = [];
    for (_i = 0, _len = particles.length; _i < _len; _i++) {
      p = particles[_i];
      if (this.hasIntersect(p)) {
        this.work(p);
      } else {
        temp.push(p);
      }
    }
    return (removal ? temp : particles);
  };

  ParticleField.prototype.work = function(p) {};

  return ParticleField;

})(Rectangle);

window.Pt = window.Pt || {};

Pt.ParticleField = ParticleField;

ParticleEmitter = (function(_super) {

  __extends(ParticleEmitter, _super);

  ParticleEmitter.name = 'ParticleEmitter';

  function ParticleEmitter() {
    ParticleEmitter.__super__.constructor.apply(this, arguments);
    this.system = null;
    this.lastTime = 0;
    this.animateID = -1;
  }

  ParticleEmitter.prototype.frequency = function(f) {
    return this.period = 1000 / f;
  };

  ParticleEmitter.prototype.emit = function() {};

  ParticleEmitter.prototype.animate = function(time, frame, ctx) {
    if (time - this.lastTime > this.period) {
      this.emit();
      return this.lastTime = time;
    }
  };

  return ParticleEmitter;

})(Vector);

window.Pt = window.Pt || {};

Pt.ParticleEmitter = ParticleEmitter;

GridCascade = (function(_super) {

  __extends(GridCascade, _super);

  GridCascade.name = 'GridCascade';

  function GridCascade() {
    GridCascade.__super__.constructor.apply(this, arguments);
    this.startRow = 0;
  }

  GridCascade.prototype.resetLayout = function() {
    this.layout = [];
    return this.startRow = 0;
  };

  GridCascade.prototype.occupy = function(x, y, w, h) {
    var c, r, _i, _j, _ref, _ref1;
    for (c = _i = x, _ref = w + x; x <= _ref ? _i < _ref : _i > _ref; c = x <= _ref ? ++_i : --_i) {
      for (r = _j = y, _ref1 = h + y; y <= _ref1 ? _j < _ref1 : _j > _ref1; r = y <= _ref1 ? ++_j : --_j) {
        if (!(this.layout[r] != null)) {
          this.layout[r] = [];
        }
        this.layout[r][c] = 1;
      }
    }
    return this;
  };

  GridCascade.prototype.findStartRow = function() {
    var c, index, r, _i, _j, _ref, _ref1, _ref2;
    index = this.startRow;
    for (r = _i = _ref = this.startRow, _ref1 = this.rows; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; r = _ref <= _ref1 ? ++_i : --_i) {
      index = r;
      for (c = _j = 0, _ref2 = this.columns; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; c = 0 <= _ref2 ? ++_j : --_j) {
        if (this.layout[r] != null) {
          if (!(this.layout[r][c] != null) || this.layout[r][c] <= 0) {
            return index;
          }
        }
      }
    }
    return index;
  };

  GridCascade.prototype.fit = function(cols, rows) {
    var allRowsFree, b, cell, colCount, colSize, currCol, currRow, freeCol, rc, _i, _j, _k, _ref, _ref1, _ref2, _ref3;
    colSize = Math.min(cols, this.columns);
    for (currRow = _i = _ref = this.startRow, _ref1 = this.rows; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; currRow = _ref <= _ref1 ? ++_i : --_i) {
      colCount = colSize;
      freeCol = 0;
      if (currRow + rows >= this.rows) {
        this.rows += rows;
      }
      if (!(this.layout[currRow] != null)) {
        this.layout[currRow] = [];
      }
      for (currCol = _j = 0, _ref2 = this.columns; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; currCol = 0 <= _ref2 ? ++_j : --_j) {
        cell = this.layout[currRow][currCol];
        if ((cell != null) && cell > 0) {
          freeCol = currCol + 1;
          colCount = colSize;
        } else {
          colCount--;
          if (colCount === 0) {
            allRowsFree = true;
            if (rows > 1) {
              for (rc = _k = currRow, _ref3 = currRow + rows; currRow <= _ref3 ? _k < _ref3 : _k > _ref3; rc = currRow <= _ref3 ? ++_k : --_k) {
                if (rc <= this.rows && (this.layout[rc] != null) && this.layout[rc][freeCol] > 0) {
                  allRowsFree = false;
                  break;
                }
              }
            }
            if (allRowsFree) {
              this.occupy(freeCol, currRow, colSize, rows);
              if (currRow > this.startRow) {
                this.startRow = this.findStartRow();
              }
              b = new Rectangle(this.$add(this.cell.size.$multiply(freeCol, currRow)));
              b.resizeTo(this.cell.size.$multiply(colSize, rows));
              return {
                row: currRow,
                column: freeCol,
                columnSize: colSize,
                rowSize: rows,
                bound: b
              };
            }
          }
        }
      }
    }
    console.error("cannot fit " + currRow + " " + freeCol + " " + cols + " " + rows);
    return false;
  };

  return GridCascade;

})(Grid);

window.Pt = window.Pt || {};

Pt.GridCascade = GridCascade;
