{
  "CanvasSpace": {
    "cls": "CanvasSpace", 
    "description": "<h3>An html canvas Space</h3>", 
    "extend": "Space", 
    "file": "CanvasSpace.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a CanvasSpace which represents a HTML Canvas Space</h2>", 
        "name": "CanvasSpace", 
        "param": [
          "<p><code>id</code> an id property which refers to the \"id\" attribute of the canvas element in DOM. If no canvas element with this id is found, a new canvas element will be created.</p>", 
          "<p><code>context</code> a string of canvas context type, such as \"2d\" or \"webgl\". Default is \"2d\"</p>", 
          "<p><code>bgcolor</code> a background color string to specify the canvas background. Default is <code>false</code> which shows a transparent background.</p>"
        ], 
        "pname": "id='pt_space', bgcolor=false, context='2d'"
      }, 
      {
        "description": "<h2>Place a new canvas element to a page dom element. When canvas is ready, a \"ready\" event will be fired. Track this event with <code>space.canvas.addEventListener(\"ready\")</code></h2>", 
        "name": "display", 
        "param": [
          "<p><code>parent_id</code> the DOM element into which the canvas element should be appended</p>", 
          "<p><code>readyCallback</code> a callback function with parameters <code>width</code>, <code>height</code>, and <code>canvas_element</code>, which will get called when canvas is appended and ready.</p>"
        ], 
        "pname": "parent_id=\"#pt\", readyCallback", 
        "return": "<p>this CanvasSpace</p>"
      }, 
      {
        "description": "<h2>This overrides Space's <code>resize</code> function and it's a callback function for window resize event. The resize event is passed to the Space's added items that has defined a <code>onSpaceResize(w,h,evt)</code></h2>", 
        "name": "resize", 
        "param": [], 
        "pname": "w, h, evt", 
        "return": "<p>this CanvasSpace</p>"
      }, 
      {
        "description": "<h2>Clear the canvas with its background color. Overrides Space's <code>clear</code> function.</h2>", 
        "name": "clear", 
        "param": [
          "<p><code>bg</code> Optionally specify a custom background color. If evaluated to false, it will use its <code>bgcolor</code> property as background color.</p>"
        ], 
        "pname": "bg", 
        "return": "<p>this CanvasSpace</p>"
      }, 
      {
        "description": "<h2>Overrides Space's <code>animate</code> function for canvas</h2>", 
        "name": "animate", 
        "param": [
          "<p><code>time</code> current time</p>"
        ], 
        "pname": "time", 
        "return": "<p>this CanvasSpace</p>"
      }, 
      {
        "description": "<h2>Bind event listener in canvas element, for events such as mouse events</h2>", 
        "name": "bindCanvas", 
        "param": [
          "<p><code>evt</code> Event object</p>", 
          "<p><code>callback</code> a callback function for this event</p>"
        ], 
        "pname": "evt, callback"
      }, 
      {
        "description": "<h2>A convenient method to bind (or unbind) all mouse events in canvas element. All item added to <code>items</code> property that implements an <code>onMouseAction</code> callback will receive mouse event callbacks.</h2>", 
        "name": "bindMouse", 
        "param": [
          "<p><code>bind</code> a boolean value to bind mouse events if set to <code>true</code>. If <code>false</code>, all mouse events will be unbound. Default is true.</p>"
        ], 
        "pname": "_bind=true"
      }
    ], 
    "props": [
      {
        "description": "<h2>A property to store canvas DOM element</h2>", 
        "name": "canvas", 
        "param": []
      }, 
      {
        "description": "<h2>A boolean property to track if the canvas element is added to dom or not</h2>", 
        "name": "appended", 
        "param": []
      }
    ], 
    "statics": []
  }, 
  "Circle": {
    "cls": "Circle", 
    "description": "<h3>A circle</h3>", 
    "extend": "Vector", 
    "file": "Circle.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new Circle. A Circle is a Vector which defines its center position, with a <code>radius</code> property to define its radius.</h2>", 
        "eg": "<p><code>new Circle()</code> <code>new Circle(1,2,3)</code> <code>new Circle(1,2,3,100)</code></p>", 
        "name": "Circle", 
        "param": [
          "<p><code>args</code> Similar to Point constructor, use comma-separated values, an array, or a Point object as parameters to specify the center of circle. Optionally include a 4th parameter to set the radius directly, or use <code>setRadius()</code> afterwards.</p>"
        ], 
        "pname": "", 
        "return": "<p>a new Circle object</p>"
      }, 
      {
        "description": "<h2>set radius of the circle</h2>", 
        "name": "setRadius", 
        "param": [
          "<p><code>r</code> radius value</p>"
        ], 
        "pname": "r", 
        "return": "<p>this Circle</p>"
      }, 
      {
        "description": "<h2>Check if a point is on this Circle on xy axis.</h2>", 
        "eg": "<p><code>circle.intersectPoint(1,2,3)</code> <code>circle.intersectPoint(pt)</code></p>", 
        "name": "intersectPoint", 
        "param": [
          "<p><code>args</code> comma-separated values, or an array, or a Point object</p>"
        ], 
        "pname": "args", 
        "return": "<p>a boolean value to indicate if there is an intersection</p>"
      }, 
      {
        "description": "<h2>Check intersections between this Circle and an infinite Line on xy axis. Based on <a href=\"http://stackoverflow.com/questions/13053061/circle-line-intersection-points\">this algorithm</a>.</h2><p>@get_pts <code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>", 
        "name": "intersectPath", 
        "param": [
          "<p><code>path</code> a Pair or Line object to specify an infinite line</p>"
        ], 
        "pname": "path, get_pts=true", 
        "return": "<p>s an Array of intersection points (zero, one, or two points), or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Check intersections between this Circle and a Line segment on xy axis.</h2><p>@get_pts <code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>", 
        "name": "intersectLine", 
        "param": [
          "<p><code>line</code> a Pair or Line object to specify a line segment</p>"
        ], 
        "pname": "line, get_pts=true", 
        "return": "<p>s an Array of intersection points (zero, one, or two points), or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Check if this cirlce intersects with a set of lines ( useful for polygon or polyline such as <code>rectangle.sides()</code> ) on xy axis.</h2><p>@get_pts <code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>", 
        "eg": "<p><code>circle.intersectLines( rect.sides() )</code> <code>circle.intersectLines( pointset.sides(), true )</code></p>", 
        "name": "intersectLines", 
        "param": [
          "<p><code>lines</code> an array of Line</p>"
        ], 
        "pname": "lines, get_pts=true", 
        "return": "<p>s an Array of intersection points, or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Check if this circle intersects with another circle</h2><p>@get_pts <code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>", 
        "name": "intersectCircle", 
        "param": [
          "<p><code>circle</code> another Circle</p>"
        ], 
        "pname": "circle, get_pts=true", 
        "return": "<p>s an Array of intersection points (zero or two points) or a boolean value, based on <code>get_pts</code> parameter.</p>"
      }, 
      {
        "description": "<h2>Check if this cirlce intersect with another element on xy axis</h2>", 
        "eg": "<p><code>circle.hasIntersect( another_circle )</code> <code>circle.hasIntersect(line)</code> <code>circle.hasIntersect(rect)</code></p>", 
        "name": "hasIntersect", 
        "param": [
          "<p><code>item</code> any object that is based on Point. (Vector, Line, Rectangle, Circle, etc)</p>"
        ], 
        "pname": "item, get_pts=false", 
        "return": "<p>s an Array of intersection points or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }
    ], 
    "props": [
      {
        "description": "<h2>the radius property</h2>", 
        "name": "radius", 
        "param": []
      }
    ], 
    "statics": []
  }, 
  "Color": {
    "cls": "Color", 
    "description": "<h3>A color in a color space</h3>", 
    "extend": "Vector", 
    "file": "Color.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new Color. Color lets you define a color in a specific mode. <a href=\"https://software.intel.com/en-us/node/503873\">This article</a> from Intel has a good overview of different color models.</h2>", 
        "eg": "<p><code>new Color()</code> <code>new Color(255,100,20)</code> <code>new Color([2,4])</code> <code>new Color({x:3, y:6, z:9})</code> <code>new Color(360,1,1,0.5)</code>, <code>new Color(100,50,-50,1,'lab')</code></p>", 
        "name": "Color", 
        "param": [
          "<p><code>args</code> Set the three values of a color as comma-separated values, as an array, or as an object with <code>{x, y, z}</code> properties. Optionally set <code>alpha</code> in a 4th parameter, and color mode string in 5th parameter.</p>"
        ], 
        "pname": "args", 
        "return": "<p>a new Color object</p>"
      }, 
      {
        "description": "<h2>set a color mode and convert current color to new color mode</h2>", 
        "eg": "<p><code>color.setMode('lab')</code></p>", 
        "name": "setMode", 
        "param": [
          "<p><code>m</code> a string to specify color mode: 'hsl', 'hsb', 'rgb', 'lab', 'lch', 'xyz'</p>"
        ], 
        "pname": "m", 
        "return": "<p>this Color object with new color mode</p>"
      }, 
      {
        "description": "<h2>Get rgb value as hex string such as '#123456'</h2>", 
        "name": "hex", 
        "param": [], 
        "pname": ""
      }, 
      {
        "description": "<h2>Get rgb string such as 'rgb(12,34,56)'</h2>", 
        "name": "rgb", 
        "param": [], 
        "pname": ""
      }, 
      {
        "description": "<h2>Get rgba string such as 'rgba(12,34,56, 0.2)'</h2>", 
        "name": "rgba", 
        "param": [], 
        "pname": ""
      }, 
      {
        "description": "<h2>Get color values (based on current color mode) as an array</h2>", 
        "name": "values", 
        "param": [
          "<p><code>toRGB</code> Optional boolean value to convert to rgb value if set to <code>true</code>. Default is false.</p>"
        ], 
        "pname": "toRGB=false", 
        "return": "<p>an array of colro values</p>"
      }
    ], 
    "props": [
      {
        "description": "<h2>alpha value from 0 to 1, where 0 is fully transparent, and 1 is fully opaque</h2>", 
        "name": "alpha", 
        "param": []
      }, 
      {
        "description": "<h2>color mode id such as \"lab\" or \"rgb\"</h2>", 
        "name": "mode", 
        "param": []
      }, 
      {
        "description": "<h2>A property to adject XYZ for Standard Observer 2deg, Daylight/sRGB illuminant D65</h2>", 
        "name": "XYZ", 
        "param": []
      }
    ], 
    "statics": [
      {
        "description": "<h2>A static function <code>Color.RGBtoHSL</code> to convert RGB to HSL</h2>", 
        "eg": "<p><code>Color.RGBtoHSL(255,70,0)</code> <code>Color.RGBtoHSL(1,0.3,0, true)</code></p>", 
        "name": "RGBtoHSL", 
        "param": [
          "<p><code>r, g, b</code> red, green, blue values from 0 to 255</p>", 
          "<p><code>normalizedInput, normalizedOutput</code> Optional boolean values to indicate if input parameters are normalized (0 to 1), and if return value should be normalized</p>"
        ], 
        "pname": "r, g, b, normalizedInput, normalizedOutput", 
        "return": "<p>an array of [h, s, l] where h is from 0 to 360, s is from 0 to 1, and l is from 0 to 1.</p>"
      }, 
      {
        "description": "<h2>A static function <code>Color.HSLtoRGB</code> to convert HSL to RGB</h2>", 
        "eg": "<p><code>Color.HSLtoRGB(360,0.7,0.9)</code> <code>Color.HSLtoRGB(1,0.3,0, true)</code></p>", 
        "name": "HSLtoRGB", 
        "param": [
          "<p><code>h, s, l</code> hue, saturation, and lightness. hue value from 0 to 360, saturation and lightness values from 0 to 1</p>", 
          "<p><code>normalizedInput, normalizedOutput</code> Optional boolean values to indicate if input parameters are normalized (0 to 1), and if return value should be normalized</p>"
        ], 
        "pname": "h, s, l, normalizedInput, normalizedOutput", 
        "return": "<p>an array of [r, g, b] where each value is from 0 to 255</p>"
      }, 
      {
        "description": "<h2>A static function <code>Color.RGBtoHSB</code> to convert RGB to HSB</h2>", 
        "eg": "<p><code>Color.RGBtoHSB(255,70,0)</code> <code>Color.RGBtoHSB(1,0.3,0, true)</code></p>", 
        "name": "RGBtoHSB", 
        "param": [
          "<p><code>r, g, b</code> red, green, blue values from 0 to 255</p>", 
          "<p><code>normalizedInput, normalizedOutput</code> Optional boolean values to indicate if input parameters are normalized (0 to 1), and if return value should be normalized</p>"
        ], 
        "pname": "r, g, b, normalizedInput, normalizedOutput", 
        "return": "<p>an array of [h, s, b] where h is from 0 to 360, s is from 0 to 1, and b is from 0 to 1.</p>"
      }, 
      {
        "description": "<h2>A static function <code>Color.HSBtoRGB</code> to convert HSB to RGB</h2>", 
        "eg": "<p><code>Color.HSBtoRGB(360,0.7,0.9)</code> <code>Color.HSBtoRGB(1,0.3,0, true)</code></p>", 
        "name": "HSBtoRGB", 
        "param": [
          "<p><code>h, s, b</code> hue, saturation, and brightness. hue value from 0 to 360, saturation and brightness values from 0 to 1</p>", 
          "<p><code>normalizedInput, normalizedOutput</code> Optional boolean values to indicate if input parameters are normalized (0 to 1), and if return value should be normalized</p>"
        ], 
        "pname": "h, s, v, normalizedInput, normalizedOutput", 
        "return": "<p>an array of [r, g, b] where each value is from 0 to 255</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.RGBtoLAB</code> transforms RGB to LAB</h2>", 
        "name": "RGBtoLAB", 
        "param": [
          "<p><code>r, g, b</code> red, green, and blue values from 0 to 255</p>", 
          "<p><code>normalizedInput, normalizedOutput</code> Optional boolean values to indicate if input parameters are normalized (0 to 1), and if return value should be normalized</p>"
        ], 
        "pname": "r, g, b, normalizedInput, normalizedOutput", 
        "return": "<p>an array of [L, a, b] where lightness (L) is from 0 to 100, a and b component values are from -128 to 127. red/green colors are represented in a, and yellow/blue colors are represented in b.</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.LABtoRGB</code> transforms LAB to RGB</h2>", 
        "name": "LABtoRGB", 
        "param": [
          "<p><code>L, a, b</code> lightness (L) is from 0 to 100, a and b component values are from -128 to 127. red/green colors are represented in a, and yellow/blue colors are represented in b.</p>", 
          "<p><code>normalizedInput, normalizedOutput</code> Optional boolean values to indicate if input parameters are normalized (0 to 1), and if return value should be normalized</p>"
        ], 
        "pname": "L, a, b, normalizedInput, normalizedOutput", 
        "return": "<p>an array of [r, g, b] where each value is from 0 to 255</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.RGBtoLCH</code> transforms RGB to LCH (Cylindrical Lab)</h2>", 
        "name": "RGBtoLCH", 
        "param": [
          "<p><code>r, g, b</code> red, green, and blue values from 0 to 255</p>", 
          "<p><code>normalizedInput, normalizedOutput</code> Optional boolean values to indicate if input parameters are normalized (0 to 1), and if return value should be normalized</p>"
        ], 
        "pname": "r, g, b, normalizedInput, normalizedOutput", 
        "return": "<p>an array of [L, c, h] where lightness (l) and chroma (c) is from 0 to 100, and hue (h) is from 0 to 360</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.LCHtoRGB</code> transforms LCH to RGB</h2>", 
        "name": "LCHtoRGB", 
        "param": [
          "<p><code>L, c, h</code> lightness (l) and chroma (c) is from 0 to 100, and hue (h) is from 0 to 360</p>"
        ], 
        "pname": "L, c, h, normalizedInput, normalizedOutput", 
        "return": "<p>an array of [r, g, b] where each value is from 0 to 255</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.XYZtoRGB</code> to convert XYZ to RGB. This is usually used when converting between LAB and RGB.</h2>", 
        "name": "XYZtoRGB", 
        "param": [
          "<p><code>x, y, z</code> x, y, z values from 0 to 100</p>", 
          "<p><code>normalizedInput, normalizedOutput</code> Optional boolean values to indicate if input parameters are normalized (0 to 1), and if return value should be normalized</p>"
        ], 
        "pname": "x, y, z, normalizedInput, normalizedOutput", 
        "return": "<p>an array of [r, g, b] where each value is from 0 to 255</p>"
      }, 
      {
        "description": "<h2>A static function <code>Color.RGBtoXYZ</code> to convert RGB to XYZ. This is usually used when converting between LAB and RGB.</h2>", 
        "name": "RGBtoXYZ", 
        "param": [
          "<p><code>r, g, b</code> red, green, blue values from 0 to 255</p>", 
          "<p><code>normalizedInput, normalizedOutput</code> Optional boolean values to indicate if input parameters are normalized (0 to 1), and if return value should be normalized</p>"
        ], 
        "pname": "r, g, b, normalizedInput, normalizedOutput", 
        "return": "<p>an array of [x, y, z] where each value is from 0 to 100</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.XYZtoLAB</code> to convert XYZ to LAB.</h2>", 
        "name": "XYZtoLAB", 
        "param": [
          "<p><code>x, y, z</code> x, y, z values from 0 to 100</p>"
        ], 
        "pname": "x, y, z", 
        "return": "<p>an array of [l, a, b] where lightness (L) is from 0 to 100, a and b values are from -128 to 127</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.LABtoXYZ</code> to convert LAB to XYZ.</h2>", 
        "name": "LABtoXYZ", 
        "param": [
          "<p><code>L, a, b</code> lightness (L) is from 0 to 100, a and b component values are from -128 to 127</p>"
        ], 
        "pname": "L, a, b", 
        "return": "<p>an array of [x, y, z] where each value is from 0 to 100</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.XYZtoLUV</code> to convert XYZ to LUV.</h2>", 
        "name": "XYZtoLUV", 
        "param": [
          "<p><code>x, y, z</code> x, y, z values from 0 to 100</p>"
        ], 
        "pname": "x, y, z", 
        "return": "<p>an array of [l, u, v] where lightness is from 0 to 100, u is from -134 to 220, and v is from -140 o 122</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.LUVtoXYZ</code> to convert LUV to XYZ.</h2>", 
        "name": "LUVtoXYZ", 
        "param": [
          "<p><code>L, u, v</code> lightness (L) is from 0 to 100, u is from -134 to 220, and v is from -140 o 122</p>"
        ], 
        "pname": "L, u, v", 
        "return": "<p>an array of [x, y, z] where each value is from 0 to 100</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.LABtoLCH</code> transforms LAB to Cylindrical LCH</h2>", 
        "name": "LABtoLCH", 
        "param": [
          "<p><code>L, a, b</code> lightness (L) is from 0 to 100, a and b component values are from -128 to 127</p>"
        ], 
        "pname": "L, a, b", 
        "return": "<p>an array of [l, c, h] where lightness (l) and chroma (c) is from 0 to 100, and hue (h) is from 0 to 360</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.LCHtoLAB</code> transforms Cylindrical LCH to LAB</h2>", 
        "name": "LCHtoLAB", 
        "param": [
          "<p><code>L, c, h</code> lightness (L) and chroma (c) is from 0 to 100, and hue (h) is from 0 to 360</p>"
        ], 
        "pname": "L, c, h", 
        "return": "<p>an array of [l, a, b] where lightness (L) is from 0 to 100, a and b values are from -128 to 127</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.LUVtoLCH</code> to convert LUV to LCH.</h2>", 
        "name": "LUVtoLCH", 
        "param": [
          "<p><code>L, u, v</code> lightness (L) is from 0 to 100, u is from -134 to 220, and v is from -140 o 122</p>"
        ], 
        "pname": "L, u, v", 
        "return": "<p>an array of [l, c, h] where lightness (l) and chroma (c) is from 0 to 100, and hue (h) is from 0 to 360</p>"
      }, 
      {
        "description": "<h2>Static function <code>Color.LCHtoLUV</code> transforms Cylindrical LCH to LUV</h2>", 
        "name": "LCHtoLUV", 
        "param": [
          "<p><code>L, c, h</code> lightness (L) and chroma (c) is from 0 to 100, and hue (h) is from 0 to 360</p>"
        ], 
        "pname": "L, c, h", 
        "return": "<p>an array of [l, u, v] where lightness is from 0 to 100, u is from -134 to 220, and v is from -140 o 122</p>"
      }
    ]
  }, 
  "Const": {
    "cls": "Const", 
    "description": "<h3>Various constants</h3>", 
    "extend": "", 
    "file": "Const.coffee", 
    "funcs": [], 
    "props": [
      {
        "description": "<h2>represents the xy plane</h2>", 
        "name": "xy", 
        "param": []
      }, 
      {
        "description": "<h2>represents the yz plane</h2>", 
        "name": "yz", 
        "param": []
      }, 
      {
        "description": "<h2>reporesents the xz plane</h2>", 
        "name": "xz", 
        "param": []
      }, 
      {
        "description": "<h2>represents xyz space</h2>", 
        "name": "xyz", 
        "param": []
      }, 
      {
        "description": "<h2>represents identical point or value</h2>", 
        "name": "identical", 
        "param": []
      }, 
      {
        "description": "<h2>represents right position or direction</h2>", 
        "name": "right", 
        "param": []
      }, 
      {
        "description": "<h2>represents bottom right position or direction</h2>", 
        "name": "bottom_right", 
        "param": []
      }, 
      {
        "description": "<h2>represents bottom position or direction</h2>", 
        "name": "bottom", 
        "param": []
      }, 
      {
        "description": "<h2>represents bottom left position or direction</h2>", 
        "name": "bottom_left", 
        "param": []
      }, 
      {
        "description": "<h2>represents left position or direction</h2>", 
        "name": "left", 
        "param": []
      }, 
      {
        "description": "<h2>represents top left position or direction</h2>", 
        "name": "top_left", 
        "param": []
      }, 
      {
        "description": "<h2>represents top position or direction</h2>", 
        "name": "top", 
        "param": []
      }, 
      {
        "description": "<h2>represents top right position or direction</h2>", 
        "name": "top_right", 
        "param": []
      }, 
      {
        "description": "<h2>an array of strings to label position constants above. Eg, <code>Const.sideLabels[ Const.top_left]</code> will return the string \"top left\"</h2>", 
        "name": "sideLabels", 
        "param": []
      }, 
      {
        "description": "<h2>represents an arbitrary very small number. It is set as 0.0001 here.</h2>", 
        "name": "epsilon", 
        "param": []
      }, 
      {
        "description": "<h2>two pi radian (360deg)</h2>", 
        "name": "two_pi", 
        "param": []
      }, 
      {
        "description": "<h2>half pi radian (90deg)</h2>", 
        "name": "half_pi", 
        "param": []
      }, 
      {
        "description": "<h2>pi/4 radian (45deg)</h2>", 
        "name": "quarter_pi", 
        "param": []
      }, 
      {
        "description": "<h2>pi/180 = 1 degree in radian</h2>", 
        "name": "one_degree", 
        "param": []
      }, 
      {
        "description": "<h2>multiply this constant with a radian to get a degree</h2>", 
        "name": "rad_to_deg", 
        "param": []
      }, 
      {
        "description": "<h2>multiply this constant with a degree to get a radian</h2>", 
        "name": "deg_to_rad", 
        "param": []
      }, 
      {
        "description": "<h2>Gravity acceleration (unit = m/s^2) and gravity force (unit = Newton) on 1kg of mass.</h2>", 
        "name": "gravity", 
        "param": []
      }, 
      {
        "description": "<h2>1 Newton = 0.10197 Kilogram-force</h2>", 
        "name": "newton", 
        "param": []
      }
    ], 
    "statics": []
  }, 
  "Curve": {
    "cls": "Curve", 
    "description": "<h3>Curves and splines</h3>", 
    "extend": "PointSet", 
    "file": "Curve.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new Curve. A Curve uses a set of anchor and/or control points to interpolate a curve.</h2>", 
        "eg": "<p><code>new PointSet()</code> <code>new PointSet(1,2,3)</code> <code>new PointSet([2,4])</code> <code>new PointSet({x:3, y:6, z:9}).to(1,2,3)</code> <code>new PointSet(1,2,3).to([p1, p2, p3, p4, p5])</code></p>", 
        "name": "Curve", 
        "param": [
          "<p><code>args</code> Similar to PointSet constructor, use comma-separated values, an array, or an object as parameters to specify the anchor point. Use <code>to()</code> to add points to the set.</p>"
        ], 
        "pname": "", 
        "return": "<p>a new Curve object</p>"
      }, 
      {
        "description": "<h2>Given an index for the starting position in <code>points</code> array, get the control and/or end points of a curve segment</h2>", 
        "name": "controlPoints", 
        "param": [
          "<p><code>index</code> start index in <code>points</code> array. Default is 0.</p>", 
          "<p><code>copyStart</code> an optional boolean value to indicate if the start index should be used twice. Default is false.</p>"
        ], 
        "pname": "index=0, copyStart=false", 
        "return": "<p>an object with 4 points <code>{p0, p1, p2, p3}</code></p>"
      }, 
      {
        "description": "<h2>Create a Catmull-Rom curve. Catmull-Rom is a kind of Cardinal curve with smooth-looking curve.</h2>", 
        "name": "catmullRom", 
        "param": [
          "<p><code>step</code> the number of line segments. Defaults to 10 steps.</p>"
        ], 
        "pname": "steps=10", 
        "return": "<p>an array of Points</p>"
      }, 
      {
        "description": "<h2>Interpolate to get a point on Catmull-Rom curve</h2>", 
        "name": "catmullRomPoint", 
        "param": [
          "<p><code>step</code> the point to interpolate, as an array of <code>[t, t*t, t*t*t]</code> where <code>t</code> is between 0 to 1</p>", 
          "<p><code>ctrls</code> the control points which can be provided by <code>controlPoints()</code> function</p>"
        ], 
        "pname": "step, ctrls", 
        "return": "<p>a Point on the curve</p>"
      }, 
      {
        "description": "<h2>Create a Cardinal spline curve</h2>", 
        "name": "cardinal", 
        "param": [
          "<p><code>step</code> the number of line segments. Defaults to 10 steps.</p>", 
          "<p><code>tension</code> optional value between 0 to 1 to specify a \"tension\". Default to 0.5 which is the tension for Catmull-Rom curve</p>"
        ], 
        "pname": "steps=10, tension=0.5", 
        "return": "<p>an array of Points</p>"
      }, 
      {
        "description": "<h2>Interpolate to get a point on Cardinal curve</h2>", 
        "name": "cardinalPoint", 
        "param": [
          "<p><code>step</code> the point to interpolate, as an array of <code>[t, t*t, t*t*t]</code> where <code>t</code> is between 0 to 1</p>", 
          "<p><code>ctrls</code> the control points which can be provided by <code>controlPoints()</code> function</p>", 
          "<p><code>tension</code> optional value between 0 to 1 to specify a \"tension\". Default to 0.5 which is the tension for Catmull-Rom curve</p>"
        ], 
        "pname": "step, ctrls, tension=0.5", 
        "return": "<p>a Point on the curve</p>"
      }, 
      {
        "description": "<h2>Create a Bezier curve. In a cubic bezier curve, the first and 4th points are end points, and 2nd and 3rd points are control points.</h2>", 
        "name": "bezier", 
        "param": [
          "<p><code>step</code> the number of line segments. Defaults to 10 steps</p>"
        ], 
        "pname": "steps=10", 
        "return": "<p>an array of Points</p>"
      }, 
      {
        "description": "<h2>Interpolate to get a point on a cubic Bezier curve</h2>", 
        "name": "bezierPoint", 
        "param": [
          "<p><code>step</code> the point to interpolate, as an array of <code>[t, t*t, t*t*t]</code> where <code>t</code> is between 0 to 1</p>", 
          "<p><code>ctrls</code> the control and end points which can be provided by <code>controlPoints()</code> function. The first and 4th points are end points, and 2nd and 3rd points are control points.</p>"
        ], 
        "pname": "step, ctrls", 
        "return": "<p>a Point on the curve</p>"
      }, 
      {
        "description": "<h2>Create a B-Spline cuve</h2>", 
        "name": "bspline", 
        "param": [
          "<p><code>step</code> the number of line segments. Defaults to 10 steps.</p>", 
          "<p><code>tension</code> optional value between 0 to 1 to specify a \"tension\". Or <code>false</code> to have normal tension. Default is false.</p>"
        ], 
        "pname": "steps=10, tension=false", 
        "return": "<p>an array of Points</p>"
      }, 
      {
        "description": "<h2>Interpolate to get a point on B-Spline curve</h2>", 
        "name": "bsplinePoint", 
        "param": [
          "<p><code>step</code> the point to interpolate, as an array of <code>[t, t*t, t*t*t]</code> where <code>t</code> is between 0 to 1</p>", 
          "<p><code>ctrls</code> the control points which can be provided by <code>controlPoints()</code> function</p>"
        ], 
        "pname": "step, ctrls", 
        "return": "<p>a Point on the curve</p>"
      }, 
      {
        "description": "<h2>Interpolate to get a point on B-Spline curve with tension (Duff)</h2>", 
        "name": "bsplineTensionPoint", 
        "param": [
          "<p><code>step</code> the point to interpolate, as an array of <code>[t, t*t, t*t*t]</code> where <code>t</code> is between 0 to 1</p>", 
          "<p><code>ctrls</code> the control points which can be provided by <code>controlPoints()</code> function</p>", 
          "<p><code>tension</code> optional value between 0 to 1 to specify a \"tension\". Default to 1 which is the normal tension.</p>"
        ], 
        "pname": "step, ctrls, tension=1", 
        "return": "<p>a Point on the curve</p>"
      }
    ], 
    "props": [
      {
        "description": "<h2>a boolean value to specify if this Curve is 2D or 3D. Default is <code>false</code> (2D).</h2>", 
        "name": "is3D", 
        "param": []
      }
    ], 
    "statics": []
  }, 
  "Form": {
    "cls": "Form", 
    "description": "<h3>Form visualizes the elements</h3>", 
    "extend": "", 
    "file": "Form.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new Form which is based on HTML Canvass</h2>", 
        "name": "Form", 
        "param": [
          "<p><code>cc</code> canvas rendering context object. Eg, <code>canvas.getContext('2d')</code></p>"
        ], 
        "pname": "cc", 
        "return": "<p>a new Form object</p>"
      }, 
      {
        "description": "<h2>Set current fill style</h2>", 
        "eg": "<p><code>form.fill(\"#F90\")</code> <code>form.fill(\"rgba(0,0,0,.5\")</code> <code>form.fill(false)</code></p>", 
        "name": "fill", 
        "param": [
          "<p><code>c</code> fill color which can be as color, gradient, or pattern. (See <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle\">canvas documentation</a>) Default is false (transparent)</p>"
        ], 
        "pname": "c", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Set current stroke style</h2>", 
        "eg": "<p><code>form.stroke(\"#F90\")</code> <code>form.stroke(\"rgba(0,0,0,.5\")</code> <code>form.stroke(false)</code> <code>form.stroke(\"#000\", 0.5, 'round')</code></p>", 
        "name": "stroke", 
        "param": [
          "<p><code>c</code> stroke color which can be as color, gradient, or pattern. (See <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle\">canvas documentation</a>) Default is false (transparent)</p>", 
          "<p><code>width</code> Optional value (can be floating point) to set line width</p>", 
          "<p><code>joint</code> Optional string to set line joint style. Can be \"miter\", \"bevel\", or \"round\".</p>"
        ], 
        "pname": "c, width, joint", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Set font size and font face</h2>", 
        "eg": "<p><code>form.font(24)</code> <code>form.font(12, \"Georgia\")</code></p>", 
        "name": "font", 
        "param": [
          "<p><code>size</code> an integer value to specify font size in pixels</p>", 
          "<p><code>face</code> optional name to change the font face, such as \"sans-serif\" or \"Helvetica\"</p>"
        ], 
        "pname": "size, face=@fontFace", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Draw a shape. Defaults to <code>sketch()</code>. Override this function to draw differently.</h2>", 
        "name": "draw", 
        "param": [], 
        "pname": "shape", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Default draw based on the types of shape (Point, Line, Circle, etc)</h2>", 
        "name": "sketch", 
        "param": [
          "<p><code>shape</code> any shape such as <code>Point</code> or <code>Line</code>, or an array of Points</p>"
        ], 
        "pname": "shape", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Draw a point</h2>", 
        "name": "point", 
        "param": [
          "<p><code>p</code> a Point object</p>", 
          "<p><code>halfsize</code> radius or half size of the point. Default is 2.</p>", 
          "<p><code>isCircle</code> a boolean value to specify if the point should be drawn as a circle. Default is false.</p>"
        ], 
        "pname": "p, halfsize=2, isCircle=false", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Draw a series of points</h2>", 
        "name": "points", 
        "param": [
          "<p><code>ps</code> an array of Points</p>", 
          "<p><code>halfsize</code> radius or half size of the point. Default is 2.</p>", 
          "<p><code>isCircle</code> a boolean value to specify if the point should be drawn as a circle. Default is false.</p>"
        ], 
        "pname": "ps, halfsize=2, isCircle=false", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Draw a line</h2>", 
        "name": "line", 
        "param": [
          "<p><code>p</code> a Pair object</p>"
        ], 
        "pname": "p", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Draw a series of lines</h2>", 
        "name": "lines", 
        "param": [
          "<p><code>ps</code> an array of Lines</p>"
        ], 
        "pname": "ps", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Draw a rectangle</h2>", 
        "name": "rect", 
        "param": [
          "<p><code>p</code> a Pair object</p>"
        ], 
        "pname": "p", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Draw a circle</h2>", 
        "name": "circle", 
        "param": [
          "<p><code>p</code> a Circle object</p>"
        ], 
        "pname": "p", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Draw a triangle</h2>", 
        "name": "triangle", 
        "param": [
          "<p><code>p</code> a Triangle object</p>"
        ], 
        "pname": "p", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Draw a polygon</h2>", 
        "name": "polygon", 
        "param": [
          "<p><code>ps</code> an array of Points</p>", 
          "<p><code>closePath</code> a boolean value to specify if the path should be closed (joining last point with first point)</p>"
        ], 
        "pname": "ps, closePath", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Draw a curve</h2>", 
        "name": "curve", 
        "param": [
          "<p><code>ps</code> an array of Points</p>"
        ], 
        "pname": "ps", 
        "return": "<p>this Form</p>"
      }, 
      {
        "description": "<h2>Draw text</h2>", 
        "name": "text", 
        "param": [
          "<p><code>p</code> a Point to specify anchor position</p>", 
          "<p><code>txt</code> a string of text</p>", 
          "<p><code>maxWidth</code> maximum width per line</p>", 
          "<p><code>xoff, yoff</code> x and y positional offset values</p>"
        ], 
        "pname": "p, txt, maxWidth=1000, xoff, yoff"
      }
    ], 
    "props": [
      {
        "description": "<h2>a property to reference the canvas rendering context</h2>", 
        "name": "cc", 
        "param": []
      }, 
      {
        "description": "<h2>a boolean property to set if the next drawing should be filled with current fill style</h2>", 
        "name": "filled", 
        "param": []
      }, 
      {
        "description": "<h2>a boolean property to set if the next drawing should be stroked with current stroke style</h2>", 
        "name": "stroked", 
        "param": []
      }, 
      {
        "description": "<h2>a property to specify the current font size</h2>", 
        "name": "fontSize", 
        "param": []
      }, 
      {
        "description": "<h2>a property to specify the current font face</h2>", 
        "name": "fontFace", 
        "param": []
      }
    ], 
    "statics": [
      {
        "description": "<h2>A static function to get 2d context from a canvas element in the DOM</h2>", 
        "eg": "<p><code>Form.context('my_canvas')</code></p>", 
        "name": "context", 
        "param": [
          "<p><code>canvas_id</code> the id attribute of the canvas element</p>"
        ], 
        "pname": "canvas_id", 
        "return": "<p>a canvas rendering context object</p>"
      }, 
      {
        "description": "<h2>A static function to draw a line</h2>", 
        "name": "line", 
        "param": [
          "<p><code>ctx</code> canvas rendering context</p>", 
          "<p><code>pair</code> a Pair object</p>"
        ], 
        "pname": "ctx, pair"
      }, 
      {
        "description": "<h2>A static function to draw a line</h2>", 
        "name": "lines", 
        "param": [
          "<p><code>ctx</code> canvas rendering context</p>", 
          "<p><code>pairs</code> an array of Pair objects</p>"
        ], 
        "pname": "ctx, pairs"
      }, 
      {
        "description": "<h2>A static function to draw a rectangle</h2>", 
        "name": "rect", 
        "param": [
          "<p><code>ctx</code> canvas rendering context</p>", 
          "<p><code>pair</code> a Pair object</p>", 
          "<p><code>fill</code> a boolean value to specify if the points should be filled. Default to true.</p>", 
          "<p><code>stroke</code> a boolean value to specify if the points should be stroked. Default to false.</p>"
        ], 
        "pname": "ctx, pair, fill=true, stroke=false"
      }, 
      {
        "description": "<h2>A static  function to draw a circle</h2>", 
        "name": "circle", 
        "param": [
          "<p><code>ctx</code> canvas rendering context</p>", 
          "<p><code>c</code> a Circle object</p>", 
          "<p><code>fill</code> a boolean value to specify if the points should be filled. Default to true.</p>", 
          "<p><code>stroke</code> a boolean value to specify if the points should be stroked. Default to false.</p>"
        ], 
        "pname": "ctx, c, fill=true, stroke=false"
      }, 
      {
        "description": "<h2>A static function to draw a triangle</h2>", 
        "name": "triangle", 
        "param": [
          "<p><code>ctx</code> canvas rendering context</p>", 
          "<p><code>c</code> a Triangle object</p>", 
          "<p><code>fill</code> a boolean value to specify if the points should be filled. Default to true.</p>", 
          "<p><code>stroke</code> a boolean value to specify if the points should be stroked. Default to false.</p>"
        ], 
        "pname": "ctx, tri, fill=true, stroke=false"
      }, 
      {
        "description": "<h2>A static function to draw a point</h2>", 
        "name": "point", 
        "param": [
          "<p><code>ctx</code> canvas rendering context</p>", 
          "<p><code>pt</code> a Point object</p>", 
          "<p><code>halfsize</code> radius or half size of the point. Default is 2.</p>", 
          "<p><code>fill</code> a boolean value to specify if the points should be filled. Default to true.</p>", 
          "<p><code>stroke</code> a boolean value to specify if the points should be stroked. Default to false.</p>", 
          "<p><code>circle</code> a boolean value to specify if the points should be drawn as a circle. Default to false.</p>"
        ], 
        "pname": "ctx, pt, halfsize=2, fill=true, stroke=false, circle=false"
      }, 
      {
        "description": "<h2>A static function similar to <code>Form.point()</code> but draw a series of points</h2>", 
        "name": "points", 
        "param": [
          "<p><code>ctx</code> canvas rendering context</p>", 
          "<p><code>pts</code> an array of Points</p>", 
          "<p><code>halfsize, fill, stroke, circle</code> same parameters as in <code>Form.point()</code></p>"
        ], 
        "pname": "ctx, pts, halfsize=2, fill=true, stroke=false, circle=false"
      }, 
      {
        "description": "<h2>A static function to draw a polygon</h2>", 
        "name": "polygon", 
        "param": [
          "<p><code>ctx</code> canvas rendering context</p>", 
          "<p><code>pts</code> an array of Points</p>", 
          "<p><code>closePath</code> a boolean value to specify if the path should be closed (joining last point with first point)</p>", 
          "<p><code>fill</code> a boolean value to specify if the points should be filled. Default to true.</p>", 
          "<p><code>stroke</code> a boolean value to specify if the points should be stroked. Default to true.</p>"
        ], 
        "pname": "ctx, pts, closePath=true, fill=true, stroke=true"
      }, 
      {
        "description": "<h2>A static function to draw a curve</h2>", 
        "name": "curve", 
        "param": [
          "<p><code>ctx</code> canvas rendering context</p>", 
          "<p><code>pts</code> an array of Points</p>"
        ], 
        "pname": "ctx, pts"
      }, 
      {
        "description": "<h2>A static function to draw text</h2>", 
        "name": "text", 
        "param": [
          "<p><code>ctx</code> canvas rendering context</p>", 
          "<p><code>pt</code> a Point object to specify the anchor point</p>", 
          "<p><code>txt</code> a string of text to draw</p>", 
          "<p><code>maxWidth</code> specify a maximum width per line</p>"
        ], 
        "pname": "ctx, pt, txt, maxWidth"
      }
    ]
  }, 
  "Grid": {
    "cls": "Grid", 
    "description": "<h3>Basic Grid implementation</h3>", 
    "extend": "Rectangle", 
    "file": "Grid.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new Grid. Like a Rectangle, a Grid's area are defined by two Vectors.</h2>", 
        "eg": "<p><code>new Grid()</code> <code>new Grid(1,2,3)</code> <code>new Grid([2,4])</code> <code>new Grid({x:3, y:6, z:9}).to(1,2,3)</code></p>", 
        "name": "Grid", 
        "param": [
          "<p><code>args</code> Similar to Pair constructor, use comma-separated values, an array, or an object as parameters to specify the first point. As a shortcut to <code>to()</code>, you can also pass 4 or 6 values to set both anchor and <code>p1</code> points directly as a 2d or 3d vector.</p>"
        ], 
        "pname": "", 
        "return": "<p>a new Grid object</p>"
      }, 
      {
        "description": "<h2>Describe this grid as a text string</h2>", 
        "name": "toString", 
        "param": [], 
        "pname": "", 
        "return": "<p>\"Grid width, height, columns, rows, cell\" text</p>"
      }, 
      {
        "description": "<h2>Initiate a grid</h2>", 
        "eg": "<p><code>grid.create(100,50)</code> <code>grid.create( 10,10, \"stretch\",\"stretch\")</code> <code>grid.create( 20,20, \"flex\",\"fix\")</code></p>", 
        "name": "create", 
        "param": [
          "<p><code>x</code> a value to specify cell width (if <code>xtype</code> parameter is \"fix\" or \"flex\") or column count  (if <code>xtype</code> parameter is \"stretch\")</p>", 
          "<p><code>y</code> a value to specify cell height (if <code>ytype</code> parameter is \"fix\" or \"flex\") or row count (if <code>ytype</code> parameter is \"stretch\")</p>", 
          "<p><code>xtype, ytype</code> a string to specify how columns and rows should be calculated. Use \"fix\" to specify exact cell width or height in pixels, \"flex\" to specify ideal cell width or height in pixels (which allows for flexible rounding to rows or columns), \"stretch\" to specify number of rows or columns only</p>"
        ], 
        "pname": "x, y, xtype='fix', ytype='fix'", 
        "return": "<p>this grid</p>"
      }, 
      {
        "description": "<h2>Generate or draw cell contents with a callback function. This will loop through each cell in the grid and call the callback function.</h2>", 
        "name": "generate", 
        "param": [
          "<p><code>callback</code> a callback function with these parameters ( this_grid, cell_size, cell_position, cell_row, cell_column )</p>"
        ], 
        "pname": "callback", 
        "return": "<p>this grid</p>"
      }, 
      {
        "description": "<h2>Reset the layout and its cell states</h2>", 
        "name": "resetLayout", 
        "param": [
          "<p><code>callback</code> a function with these parameters ( this_grid, cell_row, cell_column ). This will get called after each cell's reset.</p>"
        ], 
        "pname": "callback", 
        "return": "<p>this grid</p>"
      }, 
      {
        "description": "<h2>Mark a certain area in the grid layout as occupied</h2>", 
        "eg": "<p><code>grid.occupy(0,0, 5,3)</code></p>", 
        "name": "occupy", 
        "param": [
          "<p><code>x</code> column index</p>", 
          "<p><code>y</code> row index</p>", 
          "<p><code>w</code> column width</p>", 
          "<p><code>h</code> row size</p>"
        ], 
        "pname": "x, y, w, h", 
        "return": "<p>this grid</p>"
      }, 
      {
        "description": "<h2>Fit this area as much as possible within the grid's free ceels</h2>", 
        "name": "fit", 
        "param": [
          "<p><code>cols</code> number of columns</p>", 
          "<p><code>rows</code> number of rows</p>"
        ], 
        "pname": "cols, rows", 
        "return": "<p>an object with properties <code>row</code> and <code>column</code> to specify the top left position, <code>columnSize</code> and <code>rowSize</code> to specify the resulting size in grid units, and <code>bound</code> which is the actual area as a Rectangle object.</p>"
      }
    ], 
    "props": [
      {
        "description": "<h2>grid cell settings as an object with <code>.type</code> property which defines the grid type such as \"fix-fix\", and <code>.size</code> property which stores the cell size as a Vector object.</h2>", 
        "name": "cell", 
        "param": []
      }, 
      {
        "description": "<h2>property to specify number of rows in the grid</h2>", 
        "name": "rows", 
        "param": []
      }, 
      {
        "description": "<h2>property to specify number of columns in the grid</h2>", 
        "name": "columns", 
        "param": []
      }, 
      {
        "description": "<h2>property to store layout and cell states</h2>", 
        "name": "layout", 
        "param": []
      }
    ], 
    "statics": []
  }, 
  "Line": {
    "cls": "Line", 
    "description": "<h3>Line element</h3>", 
    "extend": "Pair", 
    "file": "Line.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new Line. A Line is a Pair defined by two vectors. It can be treated as an infinite line, or as a line segment with two end points.</h2>", 
        "eg": "<p><code>new Line()</code> <code>new Line(1,2,3)</code> <code>new Line([2,4])</code> <code>new Line({x:3, y:6, z:9}).to(1,2,3)</code></p>", 
        "name": "Line", 
        "param": [
          "<p><code>args</code> Similar to Pair constructor, use comma-separated values, an array, or an object as parameters to specify the first point. As a shortcut to <code>to()</code>, you can also pass 4 or 6 values to set both anchor and <code>p1</code> points directly as a 2d or 3d vector.</p>"
        ], 
        "pname": "", 
        "return": "<p>a new Pair object</p>"
      }, 
      {
        "description": "<h2>Get slope of this line</h2>", 
        "name": "slope", 
        "param": [
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "axis=Const.xy", 
        "return": "<p>slope value, or false if it divides by 0 (a vertical line)</p>"
      }, 
      {
        "description": "<h2>Get intercepts and slop of this line</h2><p>return: an Object with {xi, yi, slope} properties, or false if it divides by 0 (a vertical line)</p>", 
        "name": "intercept", 
        "param": [
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "axis=Const.xy"
      }, 
      {
        "description": "<h2>Given an interpolated point on this line, return another line of specific length that is perpendicular to this line.</h2>", 
        "eg": "<p><code>ln.getPerpendicular(0.5)</code>, <code>ln.getPerpendicular(0.2, 100, true, Const.yz)</code></p>", 
        "name": "getPerpendicular", 
        "param": [
          "<p><code>t</code> a value between 0 to 1 to interpolate a point on this line</p>", 
          "<p><code>len</code> an optional value to specify a length for the new line. Defaults to 10.</p>", 
          "<p><code>reverse</code> a boolean value to reverse the direction of the new line if set to <code>true</code></p>", 
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "t, len=10, reverse=false, axis=Const.xy", 
        "return": "<p>a new Line that's perpendicular to this line</p>"
      }, 
      {
        "description": "<h2>Find the shortest distance from a point to this line (as infinite line, not line segment)</h2><p>return the distance, which can be positive or negative value depending on the point's position.</p>", 
        "name": "getDistanceFromPoint", 
        "param": [
          "<p><code>pt</code> a Point</p>"
        ], 
        "pname": "pt"
      }, 
      {
        "description": "<h2>Find the perpendicular vector from this line to the point. You can connect the resulting vector with the point's position to draw a perpendicular line</h2>", 
        "name": "getPerpendicularFromPoint", 
        "param": [
          "<p><code>pt</code> a Point</p>", 
          "<p><code>fromProjection</code> a boolean value defaults to true. If true, the resulting vector is based on this line's position. Otherwise the vector starts from origin (0,0).</p>"
        ], 
        "pname": "pt, fromProjection=true", 
        "return": "<p>a perpendicular Vector</p>"
      }, 
      {
        "description": "<h2>Get intersection point of this line and another line (as infinite lines, not line segements)</h2>", 
        "name": "intersectPath", 
        "param": [
          "<p><code>line</code> another Line</p>", 
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "line, axis=Const.xy", 
        "return": "<p>an intersection point as Vector, or <code>false</code> if no intersection, or <code>null</code> if two lines are identical</p>"
      }, 
      {
        "description": "<h2>Get intersection point of this line segement and another line segement (not infintie lines)</h2>", 
        "name": "intersectLine", 
        "param": [
          "<p><code>line</code> another Line</p>", 
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "line, axis=Const.xy", 
        "return": "<p>an intersection point as Vector, or <code>false</code> if no intersection, or <code>null</code> if two lines are identical</p>"
      }, 
      {
        "description": "<h2>Get intersection point of between two \"grid\" lines. Grid lines are parallel to an axis, such as a horizontal or vertical line on xy plane.</h2>", 
        "name": "intersectGridLine", 
        "param": [
          "<p><code>line</code> another Line which is parallen to an axis</p>", 
          "<p><code>path_only</code> a boolean value to specify whether to check for whole path (<code>true</code>) or line segment (<code>false</code>). Defaults to <code>false</code>.</p>", 
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "line, path_only=false, axis=Const.xy", 
        "return": "<p>an intersection point as Vector, or <code>false</code> if no intersection</p>"
      }, 
      {
        "description": "<h2>Get a list of evenly distributed points on this line</h2>", 
        "name": "subpoints", 
        "param": [
          "<p><code>num</code> the number of points to get</p>"
        ], 
        "pname": "num", 
        "return": "<p>an Array of Points</p>"
      }, 
      {
        "description": "<h2>override clone</h2>", 
        "name": "clone", 
        "param": [], 
        "pname": "deep"
      }
    ], 
    "props": [], 
    "statics": [
      {
        "description": "<h2>a static function <code>Line.slope</code> to find the slope between two points</h2>", 
        "eg": "<p><code>Line.slope(pt1, pt2)</code>, <code>Line.slope(pt1, pt2, Const.yz)</code></p>", 
        "name": "slope", 
        "param": [
          "<p><code>a</code> a Point</p>", 
          "<p><code>b</code> another Point</p>", 
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "a, b, axis=Const.xy", 
        "return": "<p>slope value, or false if it divides by 0 (a vertical line)</p>"
      }, 
      {
        "description": "<h2>a static function <code>Line.intercept</code> to get x and y intercept</h2><p>return: an Object with {xi, yi, slope} properties, or false if it divides by 0 (a vertical line)</p>", 
        "eg": "<p><code>Line.intercept(pt1, pt2)</code>, <code>Line.intercept(pt1, pt2, Const.yz)</code></p>", 
        "name": "intercept", 
        "param": [
          "<p><code>a</code> a Point</p>", 
          "<p><code>b</code> another Point</p>", 
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "a, b, axis=Const.xy"
      }, 
      {
        "description": "<h2>a static function <code>Line.isPerpendicularLine</code> to check if two lines are perpendicular to each other</h2><p>return a boolean value where <code>true</code> means the two lines are perpendicular</p>", 
        "eg": "<p><code>Line.isPerpendicularLine(ln1, ln2)</code>, <code>Line.isPerpendicularLine(ln1, ln2, Const.yz)</code></p>", 
        "name": "isPerpendicularLine", 
        "param": [
          "<p><code>line1</code> a Line</p>", 
          "<p><code>line2</code> another Line</p>", 
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "line1, line2, axis=Const.xy"
      }, 
      {
        "description": "<h2>A static function <code>Line.intersectLines</code> if an element intersects with a list of lines ( useful for polygon or polyline such as <code>rectangle.sides()</code> ) on xy axis.</h2><p>@get_pts <code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>", 
        "eg": "<p><code>Line.intersectLines( rect, triangle.sides() )</code> <code>Line.intersectLines( line, pointset.sides(), true )</code></p>", 
        "name": "intersectLines", 
        "param": [
          "<p><code>lines</code> an array of Line</p>"
        ], 
        "pname": "elem, lines, get_pts=true", 
        "return": "<p>s an Array of intersection points, or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }
    ]
  }, 
  "Matrix": {
    "cls": "Matrix", 
    "description": "<h3>Various Matrix transformations</h3>", 
    "extend": "", 
    "file": "Matrix.coffee", 
    "funcs": [], 
    "props": [], 
    "statics": [
      {
        "description": "<h2>Get a 3x3 matrix for 2D rotation around an anchor point</h2>", 
        "name": "rotateAnchor2D", 
        "param": [
          "<p><code>radian</code> rotation angle in radian</p>", 
          "<p><code>anchor</code> anchor point of rotation</p>"
        ], 
        "pname": "radian, anchor, axis=Const.xy", 
        "return": "<p>an array representing a 3x3 matrix. Apply this matrix to a homongeneous vector (x,y,1) to rotate it.</p>"
      }, 
      {
        "description": "<h2>Get a 3x3 matrix to reflect a point along a line. See also <code>Line.reflect()</code> for a potentially simpler calculation</h2>", 
        "name": "reflectAnchor2D", 
        "param": [
          "<p><code>line</code> the path to define the reflection</p>"
        ], 
        "pname": "line, axis=Const.xy", 
        "return": "<p>an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.</p>"
      }, 
      {
        "description": "<h2>Get a 3x3 matrix for 2D shear from an anchor point</h2>", 
        "name": "shearAnchor2D", 
        "param": [
          "<p><code>sx, sy</code> shear scale values, usually between -1 to 1, where 0 means no change in shear.</p>", 
          "<p><code>anchor</code> anchor point of shearing</p>"
        ], 
        "pname": "sx, sy, anchor, axis=Const.xy", 
        "return": "<p>an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.</p>"
      }, 
      {
        "description": "<h2>Get a 3x3 matrix for 2D scale from an anchor point</h2>", 
        "name": "scaleAnchor2D", 
        "param": [
          "<p><code>sx, sy</code> horizontal and vertical scale values, which are usually between 0 to N, where 1 means no change in scale.</p>", 
          "<p><code>anchor</code> anchor point of scaling</p>"
        ], 
        "pname": "sx, sy, anchor, axis=Const.xy", 
        "return": "<p>an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.</p>"
      }, 
      {
        "description": "<h2>Get a 3x3 scale matrix</h2>", 
        "name": "scale2D", 
        "param": [
          "<p><code>x, y</code> horizontal and vertical scale values, which are usually between 0 to N, where 1 means no change in scale.</p>"
        ], 
        "pname": "x, y", 
        "return": "<p>an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.</p>"
      }, 
      {
        "description": "<h2>Get a 3x3 shear matrix</h2>", 
        "name": "shear2D", 
        "param": [
          "<p><code>x, y</code> shear scale values, usually between -1 to 1, where 0 means no change in shear.</p>"
        ], 
        "pname": "x, y", 
        "return": "<p>an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.</p>"
      }, 
      {
        "description": "<h2>Get a 3x3 rotate matrix</h2>", 
        "name": "rotate2D", 
        "param": [
          "<p><code>cosA, sinA</code> cosine and sine of the rotation angle.</p>"
        ], 
        "pname": "cosA, sinA", 
        "return": "<p>an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.</p>"
      }, 
      {
        "description": "<h2>Get a 3x3 translate matrix.</h2>", 
        "name": "translate2D", 
        "param": [
          "<p><code>x, y</code> horizontal and vertical offsets to move by</p>"
        ], 
        "pname": "x, y", 
        "return": "<p>an array representing a 3x3 matrix. apply this matrix to a homongeneous vector (x,y,1) to rotate it.</p>"
      }, 
      {
        "description": "<h2>Calculate a 2D transform by applying matrix to a homogeneous vector</h2>", 
        "name": "transform2D", 
        "param": [
          "<p><code>pt</code> a Point to transform</p>", 
          "<p><code>m</code> an array representing 3x3 matrix</p>", 
          "<p><code>byValue</code> a boolean value to update the values of <code>pt</code> parameter directly if set to true. If false, returns a new Vector object instead. Default is false.</p>"
        ], 
        "pname": "pt, m, axis=Const.xy, byValue=false", 
        "return": "<p>a Vector object, or the <code>pt</code> object if <code>byValue</code> is true</p>"
      }
    ]
  }, 
  "Pair": {
    "cls": "Pair", 
    "description": "<h3>A Pair of Vector</h3>", 
    "extend": "Vector", 
    "file": "Pair.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new Pair. A Pair is a Vector which defines its anchor point, and connected to another Vector through the <code>to()</code> function.</h2>", 
        "eg": "<p><code>new Pair()</code> <code>new Pair(1,2,3)</code> <code>new Pair([2,4])</code> <code>new Pair({x:3, y:6, z:9}).to(1,2,3)</code>, <code>new Pair(10,10, 20,20)</code></p>", 
        "name": "Pair", 
        "param": [
          "<p><code>args</code> Similar to Point constructor, use comma-separated values, an array, or an object as parameters to specify the first point. As a shortcut to <code>to()</code>, you can also pass 4 or 6 values to set both anchor and <code>p1</code> points directly as a 2d or 3d vector.</p>"
        ], 
        "pname": "", 
        "return": "<p>a new Pair object</p>"
      }, 
      {
        "description": "<h2>connect the other point</h2>", 
        "eg": "<p><code>pair.to(1,2,3)</code> <code>new Pair(1,2).to(3,4)</code></p>", 
        "name": "to", 
        "param": [
          "<p><code>args</code> comma-separated values, or an array, or an object</p>"
        ], 
        "pname": "", 
        "return": "<p>this Pair</p>"
      }, 
      {
        "description": "<h2>Update p1's new position by recalculating it as a relative position to the anchor point</h2>", 
        "name": "relative", 
        "param": [], 
        "pname": "", 
        "return": "<p>this Pair</p>"
      }, 
      {
        "description": "<h2>Return a new vector of p1's new position, by recalculating it as a relative position to the anchor point</h2>", 
        "name": "$relative", 
        "param": [], 
        "pname": "", 
        "return": "<p>a new Vector</p>"
      }, 
      {
        "description": "<h2>Get a new pair that's the bounding box of this pair. This is the same as calculating its top-left (min) and bottom-right (max) points.</h2>", 
        "name": "bounds", 
        "param": [], 
        "pname": "", 
        "return": "<p>a new Pair</p>"
      }, 
      {
        "description": "<h2>Check if a point is within the bounds of this pair</h2>", 
        "eg": "<p><code>pair.withinBounds( point )</code>, <code>pair.withinBounds( point, Const.yz )</code></p>", 
        "name": "withinBounds", 
        "param": [
          "<p><code>pt</code> a Point object to check.</p>", 
          "<p><code>axis</code> optional axis id such as Const.xy.</p>"
        ], 
        "pname": "pt, axis", 
        "return": "<p>a boolean value where <code>true</code> means the point is within bounds.</p>"
      }, 
      {
        "description": "<h2>Interpolate to find a point which lies somewhere on a straight path between the two points of this pair</h2>", 
        "eg": "<p><code>pair.interpolate(0.4)</code> <code>pair.interpolate(0.1, true)</code></p>", 
        "name": "interpolate", 
        "param": [
          "<p><code>t</code> a value between 0 to 1.</p>", 
          "<p><code>relative</code> an optional boolean value. If <code>true</code>, then <code>this.p1</code> will be treated as relative to the achor point. Default is <code>false</code>.</p>"
        ], 
        "pname": "t, relative=false", 
        "return": "<p>the interpolated point as Vector</p>"
      }, 
      {
        "description": "<h2>A convenient method to get the midpoint of this pair of points. Same as @interpolate( 0.5 )</h2>", 
        "name": "midpoint", 
        "param": [], 
        "pname": "", 
        "return": "<p>the middle point as Vector</p>"
      }, 
      {
        "description": "<h2>Get a vector which points to the same direction as this pair, but starts at origin (0,0)</h2>", 
        "eg": "<p><code>pair.direction()</code>, <code>pair.direction(false)</code>, <code>pair.direction().normalize()</code></p>", 
        "name": "direction", 
        "param": [
          "<p><code>reverse</code> optional parameter to reverse the direction if set to <code>true</code>. Default is <code>false</code>.</p>"
        ], 
        "pname": "reverse", 
        "return": "<p>the directional vector</p>"
      }, 
      {
        "description": "<h2>Set or get width and height of this pair</h2>", 
        "eg": "<p><code>pair.size()</code>, <code>pair.size(100, 50)</code></p>", 
        "name": "size", 
        "param": [
          "<p><code>args</code> Optional parameter to set the size of this Pair. Can be comma-separated values, or as an array, or a Point object.</p>"
        ], 
        "pname": "", 
        "return": "<p>When setting a new size, returns self. When getting size, returns a Vector whose x is the width and y is the height.</p>"
      }, 
      {
        "description": "<h2>Find distance of this pair from anchor to p1</h2>", 
        "name": "length", 
        "param": [
          "<p>: <code>sqrt</code> optional boolean value to get distance-squared value if set to <code>false</code>. Default is true.</p>"
        ], 
        "pname": "sqrt = true", 
        "return": "<p>distance value</p>"
      }, 
      {
        "description": "<h2>Check if a point lies on the left or right side of this pair's <em>ray</em>, and if the 3 points are collinear</h2>", 
        "name": "collinear", 
        "param": [
          "<p><code>point</code> a Point object to check against this pair.</p>"
        ], 
        "pname": "point", 
        "return": "<p>a value where 0 means collinear, poitive value means the point lies on left, and negative value means it's on right</p>"
      }, 
      {
        "description": "<h2>Recalculate the origin and vec so that origin is at top-left and vec is at bottom-right</h2>", 
        "name": "resetBounds", 
        "param": [], 
        "pname": "", 
        "return": "<p>this Pair</p>"
      }, 
      {
        "description": "<h2>override equal() from parent class</h2>", 
        "name": "equal", 
        "param": [], 
        "pname": "epsilon=false"
      }, 
      {
        "description": "<h2>Override clone() from parent class</h2>", 
        "name": "clone", 
        "param": [], 
        "pname": ""
      }, 
      {
        "description": "<h2>Override floor() from parent class</h2>", 
        "name": "floor", 
        "param": [], 
        "pname": ""
      }, 
      {
        "description": "<h2>Describe this Pair as a text string</h2>", 
        "name": "toString", 
        "param": [], 
        "pname": "", 
        "return": "<p>\"Pair of vectors from ... to ...\" text</p>"
      }, 
      {
        "description": "<h2>Override toArray() include <code>p1</code> in the array.</h2>", 
        "name": "toArray", 
        "param": [], 
        "pname": ""
      }
    ], 
    "props": [
      {
        "description": "<h2>A vector object which is other point in this pair.</h2>", 
        "name": "p1", 
        "param": []
      }
    ], 
    "statics": []
  }, 
  "Particle": {
    "cls": "Particle", 
    "description": "<h3>A particle with physics</h3>", 
    "extend": "Circle", 
    "file": "Particle.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new Particle. Like a Circle, specify its center position with a <code>radius</code> property to define its radius.</h2>", 
        "eg": "<p><code>new Particle()</code> <code>new Particle(1,2,3)</code> <code>new Particle(1,2,3,100)</code></p>", 
        "name": "Particle", 
        "param": [
          "<p><code>args</code> Similar to Point constructor, use comma-separated values, an array, or a Point object as parameters to specify the center of circle. Optionally include a 4th parameter to set the radius directly, or use <code>setRadius()</code> afterwards.</p>"
        ], 
        "pname": "", 
        "return": "<p>a new Circle object</p>"
      }, 
      {
        "description": "<h2>Play the particle for one time-step.</h2>", 
        "name": "play", 
        "param": [
          "<p><code>time</code> current time in milliseconds</p>", 
          "<p><code>timeDiff</code> time difference between last and current step, ie, the time of a frame.</p>"
        ], 
        "pname": "time, timeDiff"
      }, 
      {
        "description": "<h2>Integrate function using Runge-Kutta-4. Override this function to specify other integrator, such as Euler or Verlet.</h2>", 
        "name": "integrate", 
        "param": [
          "<p><code>t</code> current time in <em>seconds</em></p>", 
          "<p><code>dt</code> time difference between last and current step, in <em>seconds</em></p>"
        ], 
        "pname": "t, dt"
      }, 
      {
        "description": "<h2>Calculate all forces acting on this particle. This is called by integrate function. Override this function to implement specific force calculations.</h2>", 
        "eg": "<p><code>p.forces( {position: new Vector(), momentum: new Vector()}, t+dt )</code></p>", 
        "name": "forces", 
        "param": [
          "<p><code>state</code> a object with <code>position</code> and <code>momentum</code> Vectors</p>", 
          "<p><code>t</code> curent time in seconds</p>"
        ], 
        "pname": "state, t", 
        "return": "<p>an object with <code>force</code> property</p>"
      }, 
      {
        "description": "<h2>Apply an impulse to this particle's <code>momentum</code> and <code>velocity</code> properties</h2>", 
        "name": "impulse", 
        "param": [
          "<p><code>force_dt</code> a force Vector</p>"
        ], 
        "pname": "force_dt"
      }, 
      {
        "description": "<h2>Runge-Kutta-4 integration</h2>", 
        "name": "integrateRK4", 
        "param": [
          "<p><code>t</code> current time in <em>seconds</em></p>", 
          "<p><code>dt</code> time difference between last and current step, in <em>seconds</em></p>"
        ], 
        "pname": "t, dt"
      }, 
      {
        "description": "<h2>Simple Euler integration using momentum</h2>", 
        "name": "integrateEuler", 
        "param": [
          "<p><code>t</code> current time in <em>seconds</em></p>", 
          "<p><code>dt</code> time difference between last and current step, in <em>seconds</em></p>"
        ], 
        "pname": "t, dt"
      }, 
      {
        "description": "<h2>check Collision with a line segment (wall), and calculate the resulting velocity and momentum</h2>", 
        "name": "collideLine2d", 
        "param": [
          "<p><code>wall</code> a Line object to check collision against</p>", 
          "<p><code>precise</code> a boolean value to specify a precise collision calculation. If <code>true</code>, then the particle position will be recalculated to match the exact collision position with the line. Default is true.</p>"
        ], 
        "pname": "wall, precise=true", 
        "return": "<p>a boolean value to indicate if collision occurs</p>"
      }, 
      {
        "description": "<h2>Check if a particle hits the boundaries within a box, and calculate the resulting velocity and momentum. Precise collision positioning are not implemented.</h2>", 
        "name": "collideWithinBounds", 
        "param": [
          "<p><code>bound</code> a Rectangle object to specify a bounding box`</p>"
        ], 
        "pname": "bound", 
        "return": "<p>a boolean value to indicate if collision occurs</p>"
      }, 
      {
        "description": "<h2>Check 2D collision with another particle, and calculate the resulting velocity and momentum. Precise collision positioning are not implemented.</h2>", 
        "name": "collideParticle2d", 
        "param": [
          "<p><code>pb</code> another Particle</p>"
        ], 
        "pname": "pb", 
        "return": "<p>an array of 2 Vectors, representing this and the other particle's resulting velocity. Or <code>false</code> if collision doesn't occur.</p>"
      }
    ], 
    "props": [
      {
        "description": "<h2>A property to store this particle's id</h2>", 
        "name": "id", 
        "param": []
      }, 
      {
        "description": "<h2>A property to track this particle's states. An object with properties <code>.age</code> and <code>.maxAge</code> and a boolean proeprty <code>.active</code></h2>", 
        "name": "life", 
        "param": []
      }, 
      {
        "description": "<h2>A property to track this particle's momentum as a Vector</h2>", 
        "name": "momentum", 
        "param": []
      }, 
      {
        "description": "<h2>A property to track this particle's velocity as a Vector</h2>", 
        "name": "velocity", 
        "param": []
      }, 
      {
        "description": "<h2>A property to specify this particle's mass value. Default is 2.</h2>", 
        "name": "mass", 
        "param": []
      }, 
      {
        "description": "<h2>A property to specify this particle's friction. Defaulti is 0.</h2>", 
        "name": "friction", 
        "param": []
      }
    ], 
    "statics": [
      {
        "description": "<h2>Static function to calculate velocity and momentum after 2D collision, without precise coliision positioning. Remember to check intersection/collision before calling this.</h2>", 
        "name": "collideParticle2d", 
        "param": [
          "<p><code>pa, pb</code> two Particles</p>", 
          "<p><code>update</code> a boolean value to update the velocity and momentum of the two particle directly if set to <code>true</code>. Default is true.</p>"
        ], 
        "pname": "pa, pb, update=true, checkOverlap=true", 
        "return": "<p>an array of 2 Vectors, representing this and the other particle's resulting velocity.</p>"
      }, 
      {
        "description": "<h2>Static function to calculate gravitational forces between 2 particles. This can be used as an implementation of <code>forces()</code> function</h2>", 
        "name": "force_gravitation", 
        "param": [
          "<p><code>state</code> a object with <code>position</code> and <code>momentum</code> Vectors</p>", 
          "<p><code>t</code> curent time in seconds</p>", 
          "<p><code>pa, pb</code> two Particles</p>", 
          "<p><code>g</code> optional gravitational constant. Defaults to 0.0067.</p>"
        ], 
        "pname": "state, t, pa, pb, g=0.0067", 
        "return": "<p>an object with <code>force</code> property</p>"
      }, 
      {
        "description": "<h2>Static function of Runge-Kutta-4 integrator (adopted from gafferongames.com)</h2>", 
        "name": "RK4", 
        "param": [
          "<p><code>c, d</code> the derivative of c is d. If c is position, then d is velocity.</p>", 
          "<p><code>func</code> acceleration function(c, d, dt, t)</p>", 
          "<p><code>dt</code> change in time</p>", 
          "<p><code>t</code> current time</p>"
        ], 
        "pname": "c, d, func, dt, t", 
        "return": "<p>an object with <code>{c, d}</code> properties where the derivative of c is d.</p>"
      }
    ]
  }, 
  "ParticleSystem": {
    "cls": "ParticleSystem", 
    "description": "<h3>Particle System</h3>", 
    "extend": "", 
    "file": "ParticleSystem.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a ParticleSystem to track a set of particles</h2>", 
        "name": "ParticleSystem", 
        "param": [], 
        "pname": ""
      }, 
      {
        "description": "<h2>add a particle to the system</h2>", 
        "name": "add", 
        "param": [
          "<p><code>particle</code> a Particle</p>"
        ], 
        "pname": "particle", 
        "return": "<p>this system</p>"
      }, 
      {
        "description": "<h2>remove a particle which has a <code>particle.life</code> property. This marks the <code>particle.life.complete</code> as <code>true</code> for removal in next cycle.</h2>", 
        "name": "remove", 
        "param": [
          "<p><code>particle</code> a Particle</p>"
        ], 
        "pname": "particle", 
        "return": "<p>this system</p>"
      }, 
      {
        "description": "<h2>animate callback function which is called by<code>Space.play()</code>. Override this callback function to specify other animation loops</h2>", 
        "name": "animate", 
        "param": [
          "<p><code>time, frame, ctx</code> parameters for current time, fps, and rendering context, which will be passed by <code>Space</code> in callback</p>"
        ], 
        "pname": "time, frame, ctx"
      }
    ], 
    "props": [
      {
        "description": "<h2>a property to store particles in this system as an Array</h2>", 
        "name": "count", 
        "param": []
      }, 
      {
        "description": "<h2>a property to track time in milliseconds</h2>", 
        "name": "time", 
        "param": []
      }
    ], 
    "statics": []
  }, 
  "Point": {
    "cls": "Point", 
    "description": "<h3>A point is the smallest expressible concept within a space. To see an infinitesimal point in an infinite space, in your mind's eyes, is to gaze upon being and nothingness. A point defines a precise position, and while formless and unchanging, it provides the basis for creation, for endless possibilities in ideas and forms. Imagine a point not only in physical or visual spaces, but also on conceptual planes, in metaphysical dimensions, and ponder how all tangible and intangible forms can be reduced into points in spaces.</h3>", 
    "extend": "", 
    "file": "Point.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new point using optional parameters which can be a list of numeric values, or an array, or an object with x,y,z properties. If no parameter is specified, this will return a Point at (0,0,0) position.</h2>", 
        "eg": "<p><code>new Point()</code> <code>new Point(1,2,3)</code> <code>new Point([2,4])</code> <code>new Point({x:3, y:6, z:9})</code></p>", 
        "name": "Point", 
        "param": [
          "<p><code>args(x,y,z)</code> optional comma separated values to specify x, y, and z position</p>", 
          "<p><code>args([x,y,z])</code> optional array with 1 to 3 values to specify x, y, and z position</p>", 
          "<p><code>args(pt)</code> an optional object with <code>{x, y, z}</code> properties.</p>"
        ], 
        "pname": "args", 
        "return": "<p>a new Point object</p>"
      }, 
      {
        "demo": "point.quadrant", 
        "description": "<h2>Given another point in relation to this point, this returns which side or quadrant the other point is at. Possible</h2>", 
        "eg": "<p><code>p.quadrant( another_p )</code> <code>p.quadrant( another_p, 2 )</code></p>", 
        "name": "quadrant", 
        "param": [
          "<p><code>pt</code> a Point object</p>", 
          "<p><code>epsilon</code> an optional value to specify the minimum distance threshold. Default is Const.epsilon.</p>"
        ], 
        "pname": "pt, epsilon=Const.epsilon", 
        "return": "<p>a constant value such as Const.identical, Const.bottom, Const.top_right</p>"
      }, 
      {
        "description": "<h2>Set position of this point</h2>", 
        "eg": "<p>Eg, <code>p.set( x, y )</code> or <code>p.set( {x, y, z} )</code> or  <code>p.set( [x, y, z] )</code></p>", 
        "name": "set", 
        "param": [
          "<p><code>args</code> comma-separated values, as an array, or as a Point object.</p>"
        ], 
        "pname": "args", 
        "return": "<p>this Point</p>"
      }, 
      {
        "description": "<h2>Copy another point object to this point. Slightly faster than <code>set()</code></h2>", 
        "name": "copy", 
        "param": [
          "<p><code>p</code> a Point object to copy</p>"
        ], 
        "pname": "p", 
        "return": "<p>this Point</p>"
      }, 
      {
        "description": "<h2>Clone this point</h2>", 
        "name": "clone", 
        "param": [], 
        "pname": "", 
        "return": "<p>a new Point that is identical to this point</p>"
      }, 
      {
        "description": "<h2>Describe this point as a text string</h2>", 
        "name": "toString", 
        "param": [], 
        "pname": "", 
        "return": "<p>\"Point x, y, z\" text</p>"
      }, 
      {
        "description": "<h2>Put this vector into an array</h2>", 
        "name": "toArray", 
        "param": [], 
        "pname": "", 
        "return": "<p>an array with a single point object</p>"
      }, 
      {
        "description": "<h2>When a point has 3 dimensions <code>(x,y,z)</code>, this function converts it to a new point <code>(x,y)</code> of a specific 2D plane (such as <code>yz</code>)</h2>", 
        "eg": "<p><code>p.get2D( Const.xy )</code> <code>p.get2D(Const.yz, true)</code></p>", 
        "name": "get2D", 
        "param": [
          "<p><code>axis</code> an axis id such as <code>Const.yz</code>.</p>", 
          "<p><code>reverse</code> optional boolean value. If <code>true</code>, the mapping will be flipped. Default is false.</p>"
        ], 
        "pname": "axis, reverse=false", 
        "return": "<p>a new 2D Point</p>"
      }, 
      {
        "description": "<h2>Evaluate the minimum x,y,z of this point and another point, and get a minimum Point</h2>", 
        "eg": "<p><code>p.min(1,2)</code> <code>p.min( another_p )</code></p>", 
        "name": "min", 
        "param": [
          "<p><code>args</code> comma-separated values, as an array, or as a Point object.</p>"
        ], 
        "pname": "args", 
        "return": "<p>a new Point</p>"
      }, 
      {
        "description": "<h2>Evaluate the minimum x,y,z of this point and another point, and get a maximum Point</h2>", 
        "eg": "<p><code>p.max(1,2)</code> <code>p.max( another_p )</code></p>", 
        "name": "max", 
        "param": [
          "<p><code>args</code> comma-separated values, as an array, or as a Point object.</p>"
        ], 
        "pname": "args", 
        "return": "<p>a new Point</p>"
      }, 
      {
        "description": "<h2>Check if this point is at exactly the same position as the other point</h2>", 
        "eg": "<p><code>p.equal(1,2)</code> <code>p.equal( another_p )</code></p>", 
        "name": "equal", 
        "param": [
          "<p><code>args</code> comma-separated values, as an array, or as a Point object.</p>"
        ], 
        "pname": "args", 
        "return": "<p>boolean, true if they are equal</p>"
      }, 
      {
        "description": "<h2>Check if this point is at exactly the same position as the other point</h2>", 
        "eg": "<p><code>p.near(another_p)</code> <code>p.near( another_p, 2 )</code> <code>p.near( Point.get(1,2,3) )</code></p>", 
        "name": "near", 
        "param": [
          "<p><code>pt</code> a Point to check against</p>", 
          "<p><code>epsilon</code> an optional threshold value indicating the minimum distance that's near enough</p>"
        ], 
        "pname": "pt, epsilon=Const.epsilon", 
        "return": "<p>boolean, true if they are near</p>"
      }, 
      {
        "description": "<h2>Snap this point's position to the nearest integer</h2>", 
        "name": "floor", 
        "param": [], 
        "pname": "", 
        "return": "<p>this Point</p>"
      }
    ], 
    "props": [
      {
        "description": "<h2>property for x position</h2>", 
        "name": "x", 
        "param": []
      }, 
      {
        "description": "<h2>property for y position</h2>", 
        "name": "y", 
        "param": []
      }, 
      {
        "description": "<h2>propoerty for z position</h2>", 
        "name": "z", 
        "param": []
      }
    ], 
    "statics": [
      {
        "description": "<h2>A static function <code>Point.get()</code> which converts arrays or objects to an object with <code>{x, y, z}</code> properties.</h2>", 
        "eg": "<p><code>Point.get([2,4])</code> <code>Point.get({x:3, y:6, z:9})</code></p>", 
        "name": "get", 
        "param": [
          "<p><code>args</code> Similar to Point constructor, this accepts optional parameters which can be comma-separated values, or an array, or any object.</p>"
        ], 
        "pname": "args", 
        "return": "<p>an Object with {x, y, z} properties</p>"
      }
    ]
  }, 
  "PointSet": {
    "cls": "PointSet", 
    "description": "", 
    "extend": "Vector", 
    "file": "PointSet.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new PointSet. A PointSet is a set of points which can repsent a polygon or a polyline or a time series.</h2>", 
        "eg": "<p><code>new PointSet()</code> <code>new PointSet(1,2,3)</code> <code>new PointSet([2,4])</code> <code>new PointSet({x:3, y:6, z:9}).to(1,2,3)</code> <code>new PointSet(1,2,3).to([p1, p2, p3, p4, p5])</code></p>", 
        "name": "PointSet", 
        "param": [
          "<p><code>args</code> Similar to Point constructor, use comma-separated values, an array, or an object as parameters to specify the anchor point. Use <code>to()</code> to add points to the set.</p>"
        ], 
        "pname": "", 
        "return": "<p>a new PointSet object</p>"
      }, 
      {
        "description": "<h2>Describe this rectangle as a text string</h2>", 
        "name": "toString", 
        "param": [], 
        "pname": "", 
        "return": "<p>\"PointSet [p1... p2... p3...]\" text</p>"
      }, 
      {
        "description": "<h2>Get a copy of the <code>points</code> property as an array</h2>", 
        "name": "toArray", 
        "param": [], 
        "pname": ""
      }, 
      {
        "description": "<h2>Add a point or an array of points to this PointSet</h2>", 
        "eg": "<p><code>pset.to( 1,2,3 )</code> <code>pset.to([1,2,3]</code> <code>pset.to({x:3, y:6, z:9})</code> <code>pset.to([p1, p2, p3, p4...])</code></p>", 
        "name": "to", 
        "param": [
          "<p><code>args</code> either an Array of Points, or a single point defined by comma-separated values, an array, or an object.</p>"
        ], 
        "pname": "args", 
        "return": "<p>this PointSet</p>"
      }, 
      {
        "description": "<h2>Add a point whose position is calculated relative to this PointSet's anchor point</h2>", 
        "eg": "<p><code>pset.connectFromAnchor(1,2)</code> <code>pset.connectFromAnchor([2,4])</code> <code>pset.connectFromAnchor({x:3, y:6, z:9})</code></p>", 
        "name": "connectFromAnchor", 
        "param": [
          "<p><code>args</code> 0-3 comma-separated values, or as an array, or a Point object.</p>"
        ], 
        "pname": "args", 
        "return": "<p>this PointSet</p>"
      }, 
      {
        "description": "<h2>Remove a point or a series of points from this Points set</h2>", 
        "eg": "<p><code>pset.disconnect(3)</code>, <code>pset.disconnect(-2)</code></p>", 
        "name": "disconnect", 
        "param": [
          "<p><code>index</code> an index which can be positive or negative integer. If index is negative, the points are removed from the end. For example, <code>-2</code> will remove the last 2 points.</p>"
        ], 
        "pname": "index=-1", 
        "return": "<p>this PointSet</p>"
      }, 
      {
        "description": "<h2>Add a vector to all the points in the <code>points</code> array.</h2>", 
        "name": "pointsAdd", 
        "param": [
          "<p><code>args</code> comma-separated values, or as an array, or a Point object.</p>"
        ], 
        "pname": "args", 
        "return": "<p>this PointSet</p>"
      }, 
      {
        "description": "<h2>Same as <code>pointsAdd()</code> but returns a new array of the resulting points.</h2>", 
        "name": "$pointsAdd", 
        "param": [], 
        "pname": "args"
      }, 
      {
        "description": "<h2>Subtract a vector from all the points in the <code>points</code> array.</h2><p>pointsSubtract: (args) -&gt;</p><p>a = @_getArgs( arguments )</p><p>for p in @points</p><p>p.subtract( a )</p><p>return @</p><h2>Same as <code>pointsSubtract()</code> but returns a new array of the resulting points.</h2><p>$pointsSubtract: (args) -&gt;</p><p>a = @_getArgs( arguments )</p><p>return (p.$subtract( a ) for p in @points)</p><h2>Multiply a vector with all the points in the <code>points</code> array.</h2><p>pointsMultiply: (args) -&gt;</p><p>a = @_getArgs( arguments )</p><p>for p in @points</p><p>p.multiply( a )</p><p>return @</p><h2>Same as <code>pointsMultiply()</code> but returns a new array of the resulting points.</h2><p>$pointsMultiply: (args) -&gt;</p><p>a = @_getArgs( arguments )</p><p>return (p.$multiply( a ) for p in @points)</p><h2>Divide all the points in the <code>points</code> array with a vector.</h2><p>pointsDivide: (args) -&gt;</p><p>a = @_getArgs( arguments )</p><p>for p in @points</p><p>p.divide( a )</p><p>return @</p><h2>Same as <code>pointsDivide()</code> but returns a new array of the resulting points.</h2><p>$pointsDivide: (args) -&gt;</p><p>a = @_getArgs( arguments )</p><p>return (p.$divide( a ) for p in @points)</p><h2>Get an array of Lines that represents this PointSet's sides</h2>", 
        "name": "sides", 
        "param": [
          "<p><code>args</code> comma-separated values, or as an array, or a Point object.</p>", 
          "<p><code>args</code> comma-separated values, or as an array, or a Point object.</p>", 
          "<p><code>args</code> comma-separated values, or as an array, or a Point object.</p>", 
          "<p><code>close_path</code> a boolean value to include the side from last point to first point when set to <code>true</code></p>"
        ], 
        "pname": "close_path=true", 
        "return": "<p>an array of Lines</p>"
      }, 
      {
        "description": "<h2>Get the angles of each vertice connected by 2 sides</h2>", 
        "name": "angles", 
        "param": [
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "axis=Const.xy", 
        "return": "<p>an array of angles in radian</p>"
      }, 
      {
        "description": "<h2>Get the bounding box for this point set.</h2>", 
        "name": "bounds", 
        "param": [], 
        "pname": "", 
        "return": "<p>a Rectangle which is the bounding box of the PointSet</p>"
      }, 
      {
        "description": "<h2>Get this PointSet's centroid, which is the averge positions of its points.</h2>", 
        "name": "centroid", 
        "param": [], 
        "pname": "", 
        "return": "<p>the centroid point as Vector</p>"
      }, 
      {
        "description": "<h2>Get a convex hull of the point set using Melkman's algorithm</h2>", 
        "name": "convexHull", 
        "param": [
          "<p><code>sort</code> a boolean value to sort the <code>points</code> by x position first if set to true</p>"
        ], 
        "pname": "sort=true", 
        "return": "<p>an array of Vectors to define the convex hull</p>"
      }
    ], 
    "props": [
      {
        "description": "<h2>The points in this set as an array</h2>", 
        "name": "points", 
        "param": []
      }
    ], 
    "statics": []
  }, 
  "Rectangle": {
    "cls": "Rectangle", 
    "description": "<p>Rectangle class is a pair of points</p>", 
    "extend": "Pair", 
    "file": "Rectangle.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new Rectangle. A Rectangle is a Pair whose rectangular bounding box are defined by two Vectors. Use <code>toPointSet()</code> to convert it to a PointSet with 4 points if you need to rotate or shear it.</h2>", 
        "eg": "<p><code>new Rectangle()</code> <code>new Rectangle(1,2,3)</code> <code>new Rectangle([2,4])</code> <code>new Rectangle({x:3, y:6, z:9}).to(1,2,3)</code></p>", 
        "name": "Rectangle", 
        "param": [
          "<p><code>args</code> Similar to Pair constructor, use comma-separated values, an array, or an object as parameters to specify the first point. As a shortcut to <code>to()</code>, you can also pass 4 or 6 values to set both anchor and <code>p1</code> points directly as a 2d or 3d vector.</p>"
        ], 
        "pname": "", 
        "return": "<p>a new Rectangle object</p>"
      }, 
      {
        "description": "<h2>Describe this rectangle as a text string</h2>", 
        "name": "toString", 
        "param": [], 
        "pname": "", 
        "return": "<p>\"Rectangle x1, y1, z1, x2, y2, z2, width height\" text</p>"
      }, 
      {
        "description": "<h2>Convert this Rectangle from a pair of points to a <code>PointSet</code> which has 4 points. Note that if you want to rotate or shear this rectangle, convert this rectangle to a <code>PointSet</code> first.</h2>", 
        "name": "toPointSet", 
        "param": [], 
        "pname": "", 
        "return": "<p>a PointSet with 4 points. (top-right, bottom-right, bottom-left, top-left)</p>"
      }, 
      {
        "description": "<h2>Similar to <code>Pair</code>, this function connects the anchor with another point to define the rectangular bounds. This also calls Pair's <code>resetBounds()</code> to make sure anchor point is at top-left and <code>p1</code> is at bottom-right</h2>", 
        "eg": "<p><code>rect.to(1,2,3)</code> <code>new Rect(pt).to([3,4])</code></p>", 
        "name": "to", 
        "param": [
          "<p><code>args</code> comma-separated values, or an array, or an object</p>"
        ], 
        "pname": "args", 
        "return": "<p>this Rectangle</p>"
      }, 
      {
        "description": "<h2>Resize this rectangle by a certain amount from top left</h2>", 
        "eg": "<p><code>rect.resizeBy(1,2,3)</code> <code>rect.resizeBy( delta_vec )</code></p>", 
        "name": "resizeBy", 
        "param": [
          "<p><code>args</code> comma-separated values, or an array, or an object to specify the size change</p>"
        ], 
        "pname": "args", 
        "return": "<p>this Rectangle</p>"
      }, 
      {
        "description": "<h2>resize this rectangle by a certain amount from center</h2>", 
        "eg": "<p><code>rect.resizeCenterBy(1,2,3)</code> <code>rect.resizeCenterBy( delta_vec )</code></p>", 
        "name": "resizeCenterBy", 
        "param": [
          "<p><code>args</code> comma-separated values, or an array, or an object to specify the size change</p>"
        ], 
        "pname": "", 
        "return": "<p>this Rectangle</p>"
      }, 
      {
        "description": "<h2>resize to a specific size from top left</h2>", 
        "eg": "<p><code>rect.resizeTo(10,10)</code> <code>rect.resizeTo( size_vec )</code></p>", 
        "name": "resizeTo", 
        "param": [
          "<p><code>args</code> comma-separated values, or an array, or an object to specify the new size</p>"
        ], 
        "pname": "", 
        "return": "<p>this Rectangle</p>"
      }, 
      {
        "description": "<h2>resize to a specific size from center point</h2>", 
        "eg": "<p><code>rect.resizeCenterTo(10,10)</code> <code>rect.resizeCenterTo( size_vec )</code></p>", 
        "name": "resizeCenterTo", 
        "param": [
          "<p><code>args</code> comma-separated values, or an array, or an object to specify the new size</p>"
        ], 
        "pname": "", 
        "return": "<p>this Rectangle</p>"
      }, 
      {
        "description": "<h2>resize this rectangle so that it will enclose another rectangle. Namely, the resulting rectangle is a <em>union</em> of the two initial rectangles.</h2>", 
        "name": "enclose", 
        "param": [
          "<p><code>rect</code> another Rectangle or Pair object</p>"
        ], 
        "pname": "rect", 
        "return": "<p>this Rectangle which has the new size</p>"
      }, 
      {
        "description": "<h2>Same as <code>enclose()</code> but returns a new Rectangle</h2>", 
        "name": "$enclose", 
        "param": [
          "<p><code>rect</code> another Rectangle or Pair object</p>"
        ], 
        "pname": "rect", 
        "return": "<p>a new Rectangle which has the new size</p>"
      }, 
      {
        "description": "<h2>Check if this rectangle encloses (or is enclosed by) another rect. Use with <code>isLarger()</code> to check which rectangle is being enclosed.</h2>", 
        "name": "isEnclosed", 
        "param": [
          "<p><code>rect</code> another rectangle</p>"
        ], 
        "pname": "rect", 
        "return": "<p>a boolean value to indicate if one rectangle is enclosed by another</p>"
      }, 
      {
        "description": "<h2>Check if this rectangle is larger than another rectangle</h2>", 
        "name": "isLarger", 
        "param": [
          "<p><code>rect</code> another rectangle</p>"
        ], 
        "pname": "rect", 
        "return": "<p>a boolean value to indicate if this rectangle is larger</p>"
      }, 
      {
        "description": "<h2>Check if a Point is on this Rectangle</h2>", 
        "eg": "<p><code>rect.intersectPoint(1,2,3)</code> <code>rect.intersectPoint(pt)</code></p>", 
        "name": "intersectPoint", 
        "param": [
          "<p><code>args</code> comma-separated values, or an array, or a Point object</p>"
        ], 
        "pname": "", 
        "return": "<p>a boolean value to indicate if there is an intersection</p>"
      }, 
      {
        "description": "<h2>Check intersections between this Rectangle and an infinite Line on xy axis.</h2><p>@get_pts <code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>", 
        "name": "intersectPath", 
        "param": [
          "<p><code>path</code> a Pair or Line object to specify an infinite line</p>"
        ], 
        "pname": "line, get_pts=true", 
        "return": "<p>s an Array of intersection points (zero or two points), or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Check intersections between this Rectangle and a Line segment on xy axis.</h2><p>@get_pts <code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>", 
        "name": "intersectLine", 
        "param": [
          "<p><code>line</code> a Line to check</p>"
        ], 
        "pname": "line, get_pts=true", 
        "return": "<p>s an Array of intersection points (zero, one, or two points), or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Check if this Rectangle intersects with a list of Lines ( useful for polygon or polyline such as <code>rectangle.sides()</code> ) on xy axis.</h2><p>@get_pts <code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>", 
        "name": "intersectLines", 
        "param": [
          "<p><code>lines</code> an array of Line</p>"
        ], 
        "pname": "lines, get_pts=true", 
        "return": "<p>s an Array of intersection points, or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Check if this Rectangle intersects with another Rectangle</h2><p>@get_pts <code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>", 
        "name": "intersectRectangle", 
        "param": [
          "<p><code>rect</code> a Rectangle to check</p>"
        ], 
        "pname": "rect, get_pts=true", 
        "return": "<p>s an Array of intersection points (zero or two or four points), or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Check if this Rectangle intersect with another element</h2>", 
        "eg": "<p><code>rect.hasIntersect( another_circle )</code> <code>rect.hasIntersect(line)</code> <code>rect.hasIntersect(rect)</code></p>", 
        "name": "hasIntersect", 
        "param": [
          "<p><code>item</code> any object that is based on Point. (Vector, Line, Rectangle, Circle, etc)</p>"
        ], 
        "pname": "item, get_pts=false", 
        "return": "<p>s an Array of intersection points or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Get the corners of this rectangle as 4 Vectors</h2>", 
        "name": "corners", 
        "param": [], 
        "pname": "", 
        "return": "<p>an Object with 4 <code>Vector</code> objects as {topLeft, topRight, bottomLeft, bottomRight}</p>"
      }, 
      {
        "description": "<h2>Get the sides of this rectangle as 4 lines</h2>", 
        "name": "sides", 
        "param": [], 
        "pname": "", 
        "return": "<p>an Array of 4 <code>Line</code> objects [top, right, bottom, left]</p>"
      }, 
      {
        "description": "<h2>Get 4 rectangles from this rectangle by subdividing the quadrants</h2>", 
        "name": "quadrants", 
        "param": [], 
        "pname": "", 
        "return": "<p>an Object with 4 <code>Rectangle</code> objects as {topLeft, topRight, bottomLeft, bottomRight}</p>"
      }
    ], 
    "props": [
      {
        "description": "<h2>the center point of rectangle as Vector object</h2>", 
        "name": "center", 
        "param": []
      }
    ], 
    "statics": [
      {
        "description": "<h2>A static method <code>Rectangle.contain</code> to check if a point is within a bound</h2>", 
        "name": "contain", 
        "param": [
          "<p><code>pt</code> the Point to check</p>", 
          "<p><code>ptl</code> a Point to specify top-left position of the rectangular bounds</p>", 
          "<p><code>pbr</code>  a Point to specify bottom-right position of the rectangular bounds</p>"
        ], 
        "pname": "pt, ptl, pbr", 
        "return": "<p>a boolean value indicating if the point is contained within the rectangular bounds</p>"
      }
    ]
  }, 
  "Space": {
    "cls": "Space", 
    "description": "<h3>A space is a context for Pt elements</h3>", 
    "extend": "", 
    "file": "Space.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a Space which is the context for displaying and animating elements. Extend this to create specific Spaces, for example, a space for HTML Canvas or SVG.</h2>", 
        "name": "Space", 
        "param": [
          "<p><code>id</code> an id property to identify this space by name</p>"
        ], 
        "pname": "id='space'"
      }, 
      {
        "description": "<h2>set whether the rendering should repaint on each frame</h2>", 
        "name": "refresh", 
        "param": [], 
        "pname": "b"
      }, 
      {
        "description": "<h2>set custom render function (on resize etc)</h2>", 
        "name": "render", 
        "param": [], 
        "pname": "func"
      }, 
      {
        "description": "<h2>resize the space. (not implemented)</h2>", 
        "name": "resize", 
        "param": [], 
        "pname": "w, h"
      }, 
      {
        "description": "<h2>clear all contents in the space (not implemented)</h2>", 
        "name": "clear", 
        "param": [], 
        "pname": ""
      }, 
      {
        "description": "<h2>Add an item to this space. An item must define a callback function <code>animate( time, fps, context )</code> and will be assigned a property <code>animateID</code> automatically. An item can also optionally define a callback function <code>onSpaceResize( w, h, evt )</code></h2>", 
        "name": "add", 
        "param": [
          "<p>an object with an <code>animate( time, fps, context )</code> function, and optionall a <code>onSpaceResize( w, h, evt )</code> function</p>"
        ], 
        "pname": "item"
      }, 
      {
        "description": "<h2>Remove an item from this Space</h2>", 
        "name": "remove", 
        "param": [
          "<p>an object with an auto-assigned <code>animateID</code> property</p>"
        ], 
        "pname": "item"
      }, 
      {
        "description": "<h2>Remove all items from this Space</h2>", 
        "name": "removeAll", 
        "param": [], 
        "pname": ""
      }, 
      {
        "description": "<h2>Main play loop. This implements window.requestAnimationFrame and calls it recursively. Override this <code>play()</code> function to implemenet your own animation loop.</h2>", 
        "name": "play", 
        "param": [
          "<p><code>time</code> current time</p>"
        ], 
        "pname": "time=0"
      }, 
      {
        "description": "<h2>Pause the animation</h2>", 
        "name": "pause", 
        "param": [
          "<p><code>toggle</code> a boolean value to set if this function call should be a toggle (between pause and resume)</p>"
        ], 
        "pname": "toggle=false"
      }, 
      {
        "description": "<h2>Resume the paused animation</h2>", 
        "name": "resume", 
        "param": [], 
        "pname": ""
      }, 
      {
        "description": "<h2>Specify when the animation should stop: immediately, after a time period, or never stops.</h2>", 
        "name": "stop", 
        "param": [
          "<p><code>t</code> a value in millisecond to specify a time period to play before stopping, or <code>-1</code> to play forever, or <code>0</code> to end immediately. Default is 0 which will stop the animation immediately.</p>"
        ], 
        "pname": "t=0"
      }, 
      {
        "description": "<h2>Play animation loop, and then stop after <code>duration</code> time has passed.</h2>", 
        "name": "playTime", 
        "param": [
          "<p><code>duration</code> a value in millisecond to specify a time period to play before stopping, or <code>-1</code> to play forever</p>"
        ], 
        "pname": "duration=5000"
      }
    ], 
    "props": [
      {
        "description": "<h2>A property to identify this space by name</h2>", 
        "name": "id", 
        "param": []
      }, 
      {
        "description": "<h2>A render callback function, which needs to be implemented</h2>", 
        "name": "renderer", 
        "param": []
      }, 
      {
        "description": "<h2>A property to specify the size of this space as a Vector</h2>", 
        "name": "size", 
        "param": []
      }, 
      {
        "description": "<h2>A property to specify the center of this space as a Vector</h2>", 
        "name": "center", 
        "param": []
      }, 
      {
        "description": "<h2>A set of items in this space. An item should implement a function <code>animate()</code> and optionally another callback <code>onSpaceResize(w,h,evt)</code>, and will be assigned a property <code>animateID</code> automatically. (See <code>add()</code>)</h2>", 
        "name": "items", 
        "param": []
      }
    ], 
    "statics": []
  }, 
  "Timer": {
    "cls": "Timer", 
    "description": "<h2>Timer</h2><p>use this to track a duration</p>", 
    "extend": "", 
    "file": "Timer.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a Timer</h2>", 
        "name": "Timer", 
        "param": [
          "<p><code>d</code> duration of the timer in milliseconds</p>"
        ], 
        "pname": "d=1000"
      }, 
      {
        "description": "<h2>Start or restart the timer</h2>", 
        "name": "start", 
        "param": [
          "<p><code>reset</code> a boolean value to restart the timer from the beginning if set to <code>true</code>.</p>"
        ], 
        "pname": "reset"
      }, 
      {
        "description": "<h2>Check % of time that has elapsed currently.</h2>", 
        "name": "check", 
        "param": [], 
        "pname": "", 
        "return": "<p>a number between 0 to 1</p>"
      }
    ], 
    "props": [], 
    "statics": []
  }, 
  "Triangle": {
    "cls": "Triangle", 
    "description": "", 
    "extend": "Vector", 
    "file": "Triangle.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new triangle</h2>", 
        "eg": "<p><code>new Triangle()</code> <code>new Triangle(1,2,3)</code> <code>new Triangle([2,4])</code> <code>new Triangle({x:3, y:6, z:9})</code></p>", 
        "name": "Triangle", 
        "param": [
          "<p>Set the triangle's anchor point using 0 to 3 values. Can be comma-separated values, as an array, or as an object with <code>{x, y, z}</code> properties.</p>"
        ], 
        "pname": "", 
        "return": "<p>a new Triangle object</p>"
      }, 
      {
        "description": "<h2>Connect triangle's anchor point with the other two points</h2>", 
        "eg": "<p><code>tri.to( p1, p2)</code> <code>tri.to([1,2], [3,4]</code> <code>tri.to(1,2,3,4)</code> <code>tri.to(1,3,5,2,4,6)</code></p>", 
        "name": "to", 
        "param": [
          "<p>Parameters can be 2 objects or 2 arrays, or 4 or 6 numeric values to specify x, y, and optionally z positions</p>"
        ], 
        "pname": "args", 
        "return": "<p>this triangle</p>"
      }, 
      {
        "description": "<h2>Convert this triangle's points to an array of Vectors</h2>", 
        "name": "toArray", 
        "param": [], 
        "pname": "", 
        "return": "<p>an array of 3 vectors</p>"
      }, 
      {
        "description": "<h2>Get a text string that describes this triangle</h2>", 
        "name": "toString", 
        "param": [], 
        "pname": ""
      }, 
      {
        "description": "<h2>Convert this Triangle to a <code>PointSet</code></h2>", 
        "name": "toPointSet", 
        "param": [], 
        "pname": "", 
        "return": "<p>a PointSet with 3 points.</p>"
      }, 
      {
        "description": "<h2>Get an array of Lines that represents this triangle's 3 sides</h2>", 
        "name": "sides", 
        "param": [], 
        "pname": "", 
        "return": "<p>an array of 3 lines</p>"
      }, 
      {
        "description": "<h2>Get the triangle's 3 angles</h2>", 
        "name": "angles", 
        "param": [
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "axis=Const.xy", 
        "return": "<p>an array of 3 angles</p>"
      }, 
      {
        "description": "<h2>Get the medial, which is an inner triangle formed by connecting the midpoints of this triangle's sides</h2>", 
        "name": "medial", 
        "param": [], 
        "pname": "", 
        "return": "<p>the medial triangle</p>"
      }, 
      {
        "description": "<h2>Get this triangle's perimeter, which is the length of its 3 sides</h2>", 
        "name": "perimeter", 
        "param": [], 
        "pname": "", 
        "return": "<p>an object with 3 properties, where <code>.value</code> is the perimeter value, <code>.sides</code> is an array of 3 sides, <code>lengths</code> is an array of the 3 sides' lengths</p>"
      }, 
      {
        "description": "<h2>Get this triangle's area using Heron's formula for calculating polygon area</h2>", 
        "name": "area", 
        "param": [], 
        "pname": "", 
        "return": "<p>an object with 2 properties, where <code>.value</code> is the area value, and <code>.perimeter</code> is an object returned by <code>perimeter()</code> function</p>"
      }, 
      {
        "description": "<h2>Given a point of the triangle, the opposite side is the side which the point doesn't touch</h2>", 
        "eg": "<p><code>tri.oppositeSide(\"p1\")</code></p>", 
        "name": "oppositeSide", 
        "param": [
          "<p>specify a point by its id <code>\"p0\"</code> (the anchor point), <code>\"p1\"</code>, or <code>\"p2\"</code></p>"
        ], 
        "pname": "id", 
        "return": "<p>a Line which represents the opposite side</p>"
      }, 
      {
        "description": "<h2>Given a point of the triangle, the adjacent sides are the two side which the point touches</h2>", 
        "eg": "<p><code>tri.adjacentSides(\"p1\")</code></p>", 
        "name": "adjacentSides", 
        "param": [
          "<p>specify a point by its id <code>\"p0\"</code> (the anchor point), <code>\"p1\"</code>, or <code>\"p2\"</code></p>"
        ], 
        "pname": "id", 
        "return": "<p>an array of 2 Line which represents the adjacent sides</p>"
      }, 
      {
        "description": "<h2>Get a bisector, which is a path that splits a triangle's angle in half.</h2>", 
        "eg": "<p><code>tri.bisector(\"p1\")</code>, <code>tri.bisector(\"p0\", true)</code>, <code>tri.bisector(\"p2\", false, 10)</code></p>", 
        "name": "bisector", 
        "param": [
          "<p>the first paramter specifies a point by its id <code>\"p0\"</code>, <code>\"p1\"</code>, or <code>\"p2\"</code>. The second parameter determines if the path should be a simple vector from origin (<code>false</code>) or a line connected to the triangle's point (<code>true</code>). Optionally include a third parameter to set the length of the path.</p>"
        ], 
        "pname": "id, asLine=false, size=100", 
        "return": "<p>either a Line or a Vector, based on the second parameter</p>"
      }, 
      {
        "description": "<h2>Get a triangle's altitude, which is a line from a triangle's point to its opposite side, and perpendicular to its opposite side.</h2>", 
        "eg": "<p><code>tri.altitude(\"p1\")</code> gets a line from p1 to the side formed by p0 and p2</p>", 
        "name": "altitude", 
        "param": [
          "<p>specify a point by its id <code>\"p0\"</code> (the anchor point), <code>\"p1\"</code>, or <code>\"p2\"</code></p>"
        ], 
        "pname": "id", 
        "return": "<p>a Line representing an altitude</p>"
      }, 
      {
        "description": "<h2>Get a triangle's centroid, which is the averge positions of its three points.</h2>", 
        "name": "centroid", 
        "param": [], 
        "pname": "", 
        "return": "<p>the centroid point as Vector</p>"
      }, 
      {
        "description": "<h2>Get orthocenter, which is the intersection point of a triangle's 3 altitudes (the 3 lines that are perpendicular to its 3 opposite sides).</h2>", 
        "name": "orthocenter", 
        "param": [], 
        "pname": "", 
        "return": "<p>the orthocenter point as Vector</p>"
      }, 
      {
        "description": "<h2>Get incenter, which is the center point of its inner circle, and also the intersection point of its 3 angle bisector lines (each of which cuts one of the 3 angles in half).</h2>", 
        "name": "incenter", 
        "param": [], 
        "pname": "", 
        "return": "<p>the incenter point as Vector</p>"
      }, 
      {
        "description": "<h2>Get an interior circle, which is the largest circle completed enclosed by this triangle</h2>", 
        "name": "incircle", 
        "param": [], 
        "pname": "", 
        "return": "<p>a Circle</p>"
      }, 
      {
        "description": "<h2>Get circumcenter, which is the intersection point of its 3 perpendicular bisectors lines ( each of which divides a side in half and is perpendicular to the side)</h2>", 
        "name": "circumcenter", 
        "param": [], 
        "pname": "", 
        "return": "<p>the circumcenter point as Vector</p>"
      }, 
      {
        "description": "<h2>Get circumcircle, which is the smaller circle that encloses this triangle completely</h2>", 
        "name": "circumcircle", 
        "param": [], 
        "pname": "", 
        "return": "<p>a Circle</p>"
      }, 
      {
        "description": "<h2>Check intersections between this Triangle and an infinite Line on xy axis.</h2>", 
        "name": "intersectPath", 
        "param": [
          "<p><code>path</code> a Pair or Line object to specify an infinite line</p>", 
          "<p><code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>"
        ], 
        "pname": "path, get_pts=true, axis=Const.xy", 
        "return": "<p>s an Array of intersection points (zero or two points), or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Check intersections between this Triangle and a Line segment on xy axis.</h2>", 
        "name": "intersectLine", 
        "param": [
          "<p><code>line</code> a Line to check</p>", 
          "<p><code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>"
        ], 
        "pname": "line, get_pts=true, axis=Const.xy", 
        "return": "<p>s an Array of intersection points (zero, one, or two points), or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Check if this Triangle intersects with a set of Lines on xy axis</h2>", 
        "name": "intersectLines", 
        "param": [
          "<p><code>lines</code> an array of Line</p>", 
          "<p><code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>"
        ], 
        "pname": "lines, get_pts=true", 
        "return": "<p>s an Array of intersection points, or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Moller-Trumbore algorithm for 3D ray triangle intersection</h2>", 
        "name": "intersectPath3D", 
        "param": [], 
        "pname": "path, get_pts"
      }, 
      {
        "description": "<h2>Check if this Triangle intersects with a Rectangle</h2>", 
        "name": "intersectRectangle", 
        "param": [
          "<p><code>rect</code> a Rectangle to check</p>", 
          "<p><code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>"
        ], 
        "pname": "rect, get_pts=true", 
        "return": "<p>s an Array of intersection points (zero or two or four points), or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Check if this Triangle intersects with another Circle</h2>", 
        "name": "intersectCircle", 
        "param": [
          "<p><code>circle</code> a Circle to check</p>", 
          "<p><code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>"
        ], 
        "pname": "circle, get_pts=true", 
        "return": "<p>s an Array of intersection points (zero or two or four points), or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }, 
      {
        "description": "<h2>Check if this Triangle intersects with another Triangle</h2>", 
        "name": "intersectTriangle", 
        "param": [
          "<p><code>tri</code> a Triangle to check</p>", 
          "<p><code>get_pts</code> a boolean value to specify whether the results should include the intersection points. If <code>false</code>, then only the intersection state (true or false) will be returned.</p>"
        ], 
        "pname": "tri, get_pts=true", 
        "return": "<p>s an Array of intersection points (zero or two or four points), or a boolean value. (Based on <code>get_pts</code> parameter)</p>"
      }
    ], 
    "props": [
      {
        "description": "<h2>a vertice (corner point) of the triangle as Vector object</h2>", 
        "name": "p1", 
        "param": []
      }, 
      {
        "description": "<h2>another vertice (corner point) of the triangle as Vector object</h2>", 
        "name": "p2", 
        "param": []
      }
    ], 
    "statics": []
  }, 
  "Util": {
    "cls": "Util", 
    "description": "<h1>Various static methods and helper classes</h1>", 
    "extend": "", 
    "file": "Util.coffee", 
    "funcs": [], 
    "props": [], 
    "statics": [
      {
        "description": "<h2>A static function to convert degrees to radian</h2>", 
        "name": "toRadian", 
        "param": [
          "<p><code>degree</code> angle in degrees. ie, 180 degrees = Math.PI radian</p>"
        ], 
        "pname": "angle"
      }, 
      {
        "description": "<h2>A static function to convert radian to degrees</h2>", 
        "name": "toDegree", 
        "param": [
          "<p><code>radian</code> angle in radian. ie, Math.PI radian = 180 degrees</p>"
        ], 
        "pname": "radian"
      }, 
      {
        "description": "<h2>A static function to convert a color value (0-255) to hex \"FF\". See also <code>Color.hex()</code> and <code>Color.rgba()</code></h2>", 
        "name": "toHexColor", 
        "param": [
          "<p><code>number</code> a value between 0 to 255</p>"
        ], 
        "pname": "number", 
        "return": "<p>a string with 2 hex digits, such as \"FF\" or \"00\"</p>"
      }, 
      {
        "description": "<h2>A static function to convert a hex string to rgb value or string. See also <code>Color.parseHex()</code></h2>", 
        "eg": "<p><code>Util.toRGBColor(\"\")</code></p>", 
        "name": "toRGBColor", 
        "param": [
          "<p>hexString hex string such as \"FF9900\" or \"#FF9900\"</p>", 
          "<p>asRGBA a boolean value to set if the return value should be <code>rgba(...)</code> string</p>", 
          "<p>opacity optional opacity value between 0 to 1 for <code>rgba(...)</code> output</p>"
        ], 
        "pname": "hexString, asRGBA=false, opacity=1"
      }, 
      {
        "description": "<h2>A static function to limit a value (such as an angle, can be negative) as the modulus between 0 to max, or between -max/2 to max/2</h2>", 
        "name": "bound", 
        "param": [
          "<p><code>val</code> the value to be bound</p>", 
          "<p><code>max</code> maximum value as boundary</p>", 
          "<p><code>positive</code> a boolean value. If set to <code>true</code>, the return value will be between 0 to max; if <code>false</code>, return value will be between -max/2 to max/2. Default is <code>false</code>.</p>"
        ], 
        "pname": "val, max, positive=false", 
        "return": "<p>a value either (0 to max) or (-max/2 to max/2)</p>"
      }, 
      {
        "description": "<h2>A static function to limit an angle</h2>", 
        "name": "boundAngle", 
        "param": [
          "<p><code>ang</code> an angle to be bound</p>", 
          "<p><code>positive</code> a boolean value. If set to <code>true</code>, the return value will be between 0 to max; if <code>false</code>, return value will be between -max/2 to max/2. Default is <code>false</code>.</p>"
        ], 
        "pname": "ang, positive", 
        "return": "<p>an angle either between 0 to 360, or between -180 to 180 degrees</p>"
      }, 
      {
        "description": "<h2>A static function similar to <code>Util.boundAngle</code> but limit a radian angle between 0 to 2*PI, or between -PI to PI</h2>", 
        "name": "boundRadian", 
        "param": [], 
        "pname": "radian, positive"
      }, 
      {
        "description": "<h2>A static function to get a bounding box for a list of points</h2>", 
        "name": "boundingBox", 
        "param": [
          "<p><code>points</code> an array of points</p>", 
          "<p><code>is3D</code> a boolean value to specify if the points are 3D. Default is false which means the points are 2D.</p>"
        ], 
        "pname": "points, is3D=false", 
        "return": "<p>an Rectangle object as bounding box</p>"
      }, 
      {
        "description": "<h2>A static function to get linear interpolation between two values</h2><p>return the interpolated value</p>", 
        "name": "lerp", 
        "param": [
          "<p><code>a, b</code> first and second values</p>", 
          "<p><code>t</code> a value between 0 to 1</p>"
        ], 
        "pname": "a, b, t"
      }, 
      {
        "description": "<h2>Get a centroid point which is the averge positions of a list of points.</h2>", 
        "name": "centroid", 
        "param": [
          "<p><code>points</code> an array of points</p>"
        ], 
        "pname": "points", 
        "return": "<p>the centroid point as Vector</p>"
      }, 
      {
        "description": "<h2>Check if two numbers are equal within a threshold</h2>", 
        "name": "same", 
        "param": [
          "<p><code>a, b</code> two numbers to compare</p>", 
          "<p><code>threshold</code> the smallest difference allowed to be considered as same. Default is <code>Const.epsilon</code>.</p>"
        ], 
        "pname": "a, b, threshold=Const.epsilon", 
        "return": "<p>a boolean value where <code>true</code> means they are the same</p>"
      }, 
      {
        "description": "<h2>Check is a number is within the range of two number</h2>", 
        "name": "within", 
        "param": [
          "<p><code>p</code> the number to check</p>", 
          "<p><code>a, b</code> two numbers to set the range</p>"
        ], 
        "pname": "p, a, b", 
        "return": "<p>a boolean value where <code>true</code> means the number is within range</p>"
      }, 
      {
        "description": "<h2>Get a random value in between a range</h2>", 
        "name": "randomRange", 
        "param": [
          "<p><code>a, b</code> two numbers to set a range. <code>b</code> is optional and defaults to 0.</p>"
        ], 
        "pname": "a, b=0", 
        "return": "<p>a random number within the range</p>"
      }, 
      {
        "description": "<h2>Simple mixin implementataion</h2>", 
        "name": "mixin", 
        "param": [
          "<p><code>klass</code> the class to inject</p>", 
          "<p><code>mix</code> is the source mixin object</p>"
        ], 
        "pname": "klass, mix", 
        "return": "<p>the klass with mixin</p>"
      }, 
      {
        "description": "<h2>A helper function to extend a class</h2>", 
        "eg": "<p><code>function V() { Vector.call(this, arguments); }; Util.extend(V, Vector);</code></p>", 
        "name": "extend", 
        "param": [
          "<p><code>klass</code> constructor function</p>", 
          "<p><code>parent</code> class to inherit</p>"
        ], 
        "pname": "klass, parent", 
        "return": "<p>the extended class</p>"
      }, 
      {
        "description": "<h2>Given an array of Points (eg, in results of toArray() ), return an array of the points as copy</h2>", 
        "name": "clonePoints", 
        "param": [], 
        "pname": "array"
      }, 
      {
        "description": "<h2>Rotate from an origin using canvas rendering context</h2>", 
        "name": "contextRotateOrigin", 
        "param": [
          "<p><code>ctx</code> canvas rendering context</p>", 
          "<p><code>bound</code> the bounding box as Rectangle object</p>", 
          "<p><code>radian</code> the angle in radian to rotate</p>", 
          "<p><code>origin</code> an optional Point object to specify the anchor point of rotation. If origin is false or not set, the anchor is at the center of the <code>bound</code> bounding box</p>", 
          "<p><code>mask</code> an optional Rectangle object as mask</p>"
        ], 
        "pname": "ctx, bound, radian, origin=false, mask"
      }, 
      {
        "description": "<h2>A static function to pre-calculate a sine and cosine table. To use this, convert radian to angle as an integer, and then get table index by finding modulus <code>angle%360</code></h2>", 
        "name": "sinCosTable", 
        "param": [], 
        "pname": "", 
        "return": "<p>an object with <code>{sin, cos}</code> properties.</p>"
      }, 
      {
        "description": "<h2>A static function which check if a random number from 0 to 1 is smaller than a user defined number</h2>", 
        "name": "chance", 
        "param": [
          "<p><code>p</code> a value between 0 to 1</p>"
        ], 
        "pname": "p", 
        "return": "<p>a boolean value where true means a random number is smaller than the supplied parameter</p>"
      }
    ]
  }, 
  "Vector": {
    "cls": "Vector", 
    "description": "<h3>Vector element</h3>", 
    "extend": "Point", 
    "file": "Vector.coffee", 
    "funcs": [
      {
        "description": "<h2>Create a new Vector. A Vector extends a Point and includes functions for arithmetics.</h2>", 
        "eg": "<p><code>new Vector()</code> <code>new Vector(1,2,3)</code> <code>new Vector([2,4])</code> <code>new Vector({x:3, y:6, z:9})</code></p>", 
        "name": "Vector", 
        "param": [
          "<p><code>args</code> Similar to Point constructor, use comma-separated values, an array, or a Point object as parameters.</p>"
        ], 
        "pname": "", 
        "return": "<p>a new Vector object</p>"
      }, 
      {
        "description": "<h2>Add another vector to this vector.</h2>", 
        "eg": "<p><code>vec.add(1,2)</code> <code>vec.add([2,4])</code> <code>vec.add({x:3, y:6, z:9})</code></p>", 
        "name": "add", 
        "param": [
          "<p><code>args</code> comma-separated values, or as an array, or a Point object.</p>"
        ], 
        "pname": "args", 
        "return": "<p>this Vector</p>"
      }, 
      {
        "description": "<h2>Same as <code>add()</code> but returns a new Vector. The values of this vector are not changed.</h2>", 
        "name": "$add", 
        "param": [], 
        "pname": "args"
      }, 
      {
        "description": "<h2>Subtract another vector from this vector.</h2>", 
        "eg": "<p><code>vec.subtract(1,2)</code> <code>vec.subtract([2,4])</code> <code>vec.subtract({x:3, y:6, z:9})</code></p>", 
        "name": "subtract", 
        "param": [
          "<p><code>args</code> 0-3 comma-separated values, or as an array, or a Point object.</p>"
        ], 
        "pname": "args", 
        "return": "<p>this Vector</p>"
      }, 
      {
        "description": "<h2>Same as <code>subtract()</code> but returns a new Vector. The values of this vector are not changed.</h2>", 
        "name": "$subtract", 
        "param": [], 
        "pname": "args"
      }, 
      {
        "description": "<h2>Multiple this vector with a scalar or vector. If there's only one numberic value in the parameter, this vector will be multiplied by that scalar value. Otherwise, this vector's x,y,z values will be multiplied by the corresponding x,y,z in the parameters. Note that this is different to .dot and .cross products.</h2>", 
        "eg": "<p><code>vec.multiply(4)</code> <code>vec.multiply(1,2,3)</code> <code>vec.multiply([2,4])</code> <code>vec.multiply({x:3, y:6, z:9})</code></p>", 
        "name": "multiply", 
        "param": [
          "<p><code>args</code> 0-3 comma-separated values, or as an array, or a Point object.</p>"
        ], 
        "pname": "args", 
        "return": "<p>this Vector</p>"
      }, 
      {
        "description": "<h2>Same as <code>multiply()</code> but returns a new Vector. The values of this vector is not changed.</h2>", 
        "name": "$multiply", 
        "param": [], 
        "pname": "args"
      }, 
      {
        "description": "<h2>Similar as <code>multiply()</code> but easier to read semantically.</h2>", 
        "eg": "<p><code>vec.divide(2,4,5)</code> is the same as <code>vec.multiply(0.5, 0.25, 0.2)</code></p>", 
        "name": "divide", 
        "param": [], 
        "pname": "args", 
        "return": "<p>this Vector</p>"
      }, 
      {
        "description": "<h2>Same as <code>divide()</code> but returns a new Vector. The values of this vector is not changed.</h2>", 
        "name": "$divide", 
        "param": [], 
        "pname": "args"
      }, 
      {
        "description": "<h2>Apply a function to all points in the <code>toArray()</code> list. This is usually applied to <code>Pair</code>, <code>PointSet</code> and other objects to apply a function to all its points.</h2>", 
        "eg": "<p><code>pair.op(\"add\", 1,2,3)</code>, <code>pointset.op(\"multiply\", 2)</code></p>", 
        "name": "op", 
        "param": [
          "<p><code>name</code> a function of this class</p>", 
          "<p><code>args...</code> optional, comma-separated arguments to pass to the function</p>"
        ], 
        "pname": "name, args..."
      }, 
      {
        "description": "<h2>Similar to <code>op()</code> but apply the function to a new instance.</h2>", 
        "name": "$op", 
        "param": [], 
        "pname": "name, args..."
      }, 
      {
        "description": "<h2>Get the angle of this vector on a plane. Or get the angle from this vector to another point. If no parameter specified, this will return the angle on xy plane.</h2>", 
        "eg": "<p><code>vec.angle()</code> <code>vec.angle(Const.yz)</code> <code>vec.angle(another_pt)</code> <code>vec.angle(Const.xz, another_pt)</code> <code>new Vector(1,1).angle( new Vector(1,2) ) * Const.rad_to_deg = 90</code></p>", 
        "name": "angle", 
        "param": [
          "<p><code>axis</code> single argument as optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>", 
          "<p><code>pt</code> single argument as optional Point object to calculate the angle from this Point to another Point instead</p>", 
          "<p><code>axis, pt</code> 2 arguments in this sequence, as optional axis id and Point object to get the angle to a Point on a specific plane</p>"
        ], 
        "pname": "args", 
        "return": "<p>a radian value</p>"
      }, 
      {
        "description": "<h2>Get the change in radian between this and another vector (at origin position)</h2>", 
        "eg": "<p><code>vec.angleBetween( another_pt )</code> <code>vec.angleBetween( another_pt, Const.yz )</code></p>", 
        "name": "angleBetween", 
        "param": [
          "<p><code>vec</code> another Vector to compare against</p>", 
          "<p>axis optional axis id (eg <code>Const.xy</code>) to specify a plane</p>"
        ], 
        "pname": "vec, axis=Const.xy"
      }, 
      {
        "description": "<h2>Get the mangnitude (ie, distance from origin) of this vector. Or get the distance from this vector to another point. Default is to get the magnitude on xyz plane.</h2>", 
        "eg": "<p><code>vec.magnitude()</code> <code>vec.magnitude(false)</code> <code>vec.magnitude(Const.yz)</code> <code>vec.magnitude(another_pt)</code> <code>vec.magnitude(Const.xz, another_pt, false)</code>.</p>", 
        "name": "magnitude", 
        "param": [
          "<p><code>axis</code> single argument as optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>", 
          "<p><code>pt</code> single argument as optional Point object to calculate the distance from this Point to another Point instead</p>", 
          "<p><code>sqrt</code> single argument as optional boolean value to get distance-squared value if set to <code>false</code>. Default is true.</p>", 
          "<p><code>axis, pt, sqrt</code> 3 optional parameters can be used in this sequence to specify a plane, a Point, and whether to get squared value.</p>"
        ], 
        "pname": "args", 
        "return": "<p>magnitude value</p>"
      }, 
      {
        "description": "<h2>Get the distance between this and another point. An alias of magnitude.</h2>", 
        "name": "distance", 
        "param": [
          "<p><code>pt</code> another point</p>", 
          "<p><code>axis</code> optional axis id (eg, <code>Const.yz</code>) to specify a plane</p>"
        ], 
        "pname": "pt, axis=Const.xy", 
        "return": "<p>distance</p>"
      }, 
      {
        "description": "<h2>Normalize this vector to a unit vector, which has magnitude of 1.</h2>", 
        "name": "normalize", 
        "param": [], 
        "pname": "", 
        "return": "<p>this vector</p>"
      }, 
      {
        "description": "<h2>Get a normalized unit vector which has magnitude of 1. The original vector is not changed.</h2>", 
        "name": "$normalize", 
        "param": [], 
        "pname": "", 
        "return": "<p>a new unit vector</p>"
      }, 
      {
        "description": "<h2>Set this vector's values to its absolute value (always positive).</h2>", 
        "name": "abs", 
        "param": [], 
        "pname": "", 
        "return": "<p>this vector</p>"
      }, 
      {
        "description": "<h2>Calculate the <a href=\"http://en.wikipedia.org/wiki/Dot_product\">dot product</a> of this and another vector.</h2>", 
        "eg": "<p><code>vec.dot( another_vec )</code>, <code>vec.dot( another_vec, Const.xz )</code></p>", 
        "name": "dot", 
        "param": [
          "<p><code>p</code> a Point to calculate the dot product</p>", 
          "<p><code>axis</code> optional axis id (eg <code>Const.xy</code>) to specify a plane</p>"
        ], 
        "pname": "p, axis=Const.xyz", 
        "return": "<p>the dot product which is a scalar (numeric) value</p>"
      }, 
      {
        "description": "<h2>Calculate <a href=\"http://en.wikipedia.org/wiki/Vector_projection\">vector projection</a>. A vector projection that has the same direction as this vector but a different length. So if you draw a line from the projection vector to the vector specified in the parameter, it will be perpendicular to this vector.</h2>", 
        "eg": "<p><code>vec.projection( another_vec)</code>, , <code>vec.projection( another_vec, Const.xz )</code></p>", 
        "name": "projection", 
        "param": [
          "<p><code>vec</code> a Vector to calculate the projection</p>", 
          "<p><code>axis</code> optional axis id (eg <code>Const.xy</code>) to specify a plane</p>"
        ], 
        "pname": "vec, axis=Const.xyz", 
        "return": "<p>the vector projection</p>"
      }, 
      {
        "description": "<h2>Calculate the <a href=\"http://en.wikipedia.org/wiki/Cross_product\">cross product</a> of this and another vector.</h2>", 
        "eg": "<p><code>vec.cross( another_vec )</code></p>", 
        "name": "cross", 
        "param": [
          "<p><code>p</code> a Point to calculate the cross product</p>"
        ], 
        "pname": "p", 
        "return": "<p>the cross product which is a vector</p>"
      }, 
      {
        "description": "<h2>Get the middle vector between this and another vector</h2>", 
        "eg": "<p><code>vec.bisect( another_vec )</code></p>", 
        "name": "bisect", 
        "param": [
          "<p><code>vec</code> a Vector to calculate the bisect</p>"
        ], 
        "pname": "vec, isNormalized=false", 
        "return": "<p>a vector in the middle</p>"
      }, 
      {
        "description": "<h2>Get 2 vectors that are perpendicular to this vector</h2>", 
        "eg": "<p><code>vec.perpendicular()</code> <code>vec.perpendicular(Const.yz)</code></p>", 
        "name": "perpendicular", 
        "param": [
          "<p><code>axis</code> optional axis id (eg <code>Const.xy</code>) to specify a plane</p>"
        ], 
        "pname": "axis=Const.xy", 
        "return": "<p>an array of two vectors</p>"
      }, 
      {
        "description": "<h2>Check if another vector is perpendicular to this</h2>", 
        "eg": "<p><code>vec.isPerpendicular( another_vec )</code> <code>vec.isPerpendicular( another_vec, Const.yz )</code></p>", 
        "name": "isPerpendicular", 
        "param": [
          "<p><code>p</code> a Point to check against</p>", 
          "<p><code>axis</code> optional axis id (eg <code>Const.xy</code>) to specify a plane</p>"
        ], 
        "pname": "p, axis=Const.xyz", 
        "return": "<p>a boolean (true or false)</p>"
      }, 
      {
        "description": "<h2>Get surface normal vector. A <a href=\"http://en.wikipedia.org/wiki/Normal_%28geometry%29\">normal</a> is a vector perpendicular to a plane or object.</h2>", 
        "eg": "<p><code>vec.surfaceNormal( another_vec )</code></p>", 
        "name": "surfaceNormal", 
        "param": [
          "<p><code>p</code> a Point to calculate the surface normal</p>"
        ], 
        "pname": "p", 
        "return": "<p>the normal vector</p>"
      }, 
      {
        "description": "<h2>move origin to a new position. In subclasses of <code>Vector</code>, such as <code>Pair</code> or <code>PointSet</code>, this will move all the points.</h2>", 
        "name": "moveTo", 
        "param": [
          "<p><code>args</code> new position as 0-3 comma-separated values, or as an array, or a Point object.</p>"
        ], 
        "pname": "args"
      }, 
      {
        "description": "<h2>move origin by a certain amount. In subclasses of <code>Vector</code>, such as <code>Pair</code> or <code>PointSet</code>, this will move all the points.</h2>", 
        "name": "moveBy", 
        "param": [
          "<p><code>args</code> move amount as 0-3 comma-separated values, or as an array, or a Point object.</p>"
        ], 
        "pname": "args"
      }, 
      {
        "description": "<h2>Rotate this vector around an anchor point on a 2D plane. In subclasses of <code>Vector</code>, such as <code>Pair</code> or <code>PointSet</code>, this will rotate all the points.</h2>", 
        "eg": "<p><code>vec.rotate2D( Math.PI/2, anchor_pt )</code> <code>vec.rotate2D( 30*Const.deg_to_rad, another_pt, Const.xz )</code></p>", 
        "name": "rotate2D", 
        "param": [
          "<p><code>radian</code> a radian value specifying the angle. (where 1 degree = PI / 180 radian)</p>", 
          "<p><code>anchor</code> a Point object specifying the anchor position</p>", 
          "<p><code>axis</code> optional axis id (eg <code>Const.xy</code>) to specify a plane</p>"
        ], 
        "pname": "radian, anchor, axis=Const.xy", 
        "return": "<p>this vector</p>"
      }, 
      {
        "description": "<h2>Reflect this vector along a path. In subclasses of <code>Vector</code>, such as <code>Pair</code> or <code>PointSet</code>, this will reflect all the points.</h2>", 
        "eg": "<p><code>vec.reflect2D( line )</code> <code>vec.reflect2D( line, Const.xz )</code></p>", 
        "name": "reflect2D", 
        "param": [
          "<p><code>line</code> a Line object to specify the path</p>", 
          "<p><code>axis</code> optional axis id (eg <code>Const.xy</code>) to specify a plane</p>"
        ], 
        "pname": "line, axis=Const.xy", 
        "return": "<p>this vector</p>"
      }, 
      {
        "description": "<h2>Rescale this vector from an anchor point. In subclasses of <code>Vector</code>, such as <code>Pair</code> or <code>PointSet</code>, this will scale all the points together.</h2>", 
        "eg": "<p><code>vec.scale2D( 0.7, 1.2, anchor_pt )</code> <code>vec.scale2D( 1, 3, anchor_pt, Const.xz )</code></p>", 
        "name": "scale2D", 
        "param": [
          "<p><code>sx</code> x scale value, where 1 = no change</p>", 
          "<p><code>sy</code> y scale value, where 1 = no change</p>", 
          "<p><code>anchor</code> a Point object specifying the anchor position to scale from</p>", 
          "<p><code>axis</code> optional axis id (eg <code>Const.xy</code>) to specify a plane</p>"
        ], 
        "pname": "sx, sy, anchor, axis=Const.xy", 
        "return": "<p>this vector</p>"
      }, 
      {
        "description": "<h2>Shear this vector from an anchor point. In subclasses of <code>Vector</code>, such as <code>Pair</code> or <code>PointSet</code>, this will shear all the points together.</h2>", 
        "eg": "<p><code>vec.scale2D( 0.7, 1.2, anchor_pt )</code> <code>vec.scale2D( 1, 3, anchor_pt, Const.xz )</code></p>", 
        "name": "shear2D", 
        "param": [
          "<p><code>sx</code> x scale value, where 1 = no change</p>", 
          "<p><code>sy</code> y scale value, where 1 = no change</p>", 
          "<p><code>anchor</code> a Point object specifying the anchor position to scale from</p>", 
          "<p><code>axis</code> optional axis id (eg <code>Const.xy</code>) to specify a plane</p>"
        ], 
        "pname": "sx, sy, anchor, axis=Const.xy", 
        "return": "<p>this vector</p>"
      }, 
      {
        "description": "<h2>Clone this vector</h2>", 
        "name": "clone", 
        "param": [], 
        "pname": "", 
        "return": "<p>a new vector identical to this vector</p>"
      }, 
      {
        "description": "<h2>Describe this point as a text string</h2>", 
        "name": "toString", 
        "param": [], 
        "pname": "", 
        "return": "<p>\"Vector x, y, z\" text</p>"
      }
    ], 
    "props": [], 
    "statics": []
  }
}